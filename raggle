#!/usr/bin/env ruby
# -*- Mode: Ruby -*-

#######################################################################
# Raggle - Console RSS aggregator                                     #
# by Paul Duncan <pabs@pablotron.org> and                             #
#    Richard Lowe <richlowe@richlowe.net>                             #
#                                                                     #
#                                                                     #
# Please see the Raggle page at http://www.raggle.org/ for the latest #
# version of this software.                                           #
#                                                                     #
#                                                                     #
# Copyright (C) 2003 Paul Duncan, and various contributors.           #
#                                                                     #
# Permission is hereby granted, free of charge, to any person         #
# obtaining a copy of this software and associated documentation      #
# files (the "Software"), to deal in the Software without             #
# restriction, including without limitation the rights to use, copy,  #
# modify, merge, publish, distribute, sublicense, and/or sell copies  #
# of the Software, and to permit persons to whom the Software is      #
# furnished to do so, subject to the following conditions:            #
#                                                                     #
# The above copyright notice and this permission notice shall be      #
# included in all copies of the Software, its documentation and       #
# marketing & publicity materials, and acknowledgment shall be given  #
# in the documentation, materials and software packages that this     #
# Software was used.                                                  #
#                                                                     #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  #
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND               #
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY    #
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF          #
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  #
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.     #
#######################################################################

# Raggle version
$VERSION = '0.2.0'

# As early as possible, ^C and ^\ are common, and dumping a trace is ugly
# On the other hand, dumping trace is very useful when running tests, therefore
# disable these unless this file is executed.
if __FILE__ == $0
  trap('INT') { puts "Interrupted"; exit -1 }
  trap('QUIT') { puts "Quit"; exit -1 }
end

# load required modules
require 'getoptlong'
require 'ncurses'
require 'net/http'
require 'pstore'
require 'rexml/document'
require 'yaml'

begin 
  require 'net/https'
  $HAVE_SSL = true
rescue LoadError
  $HAVE_SSL = false
end

###################
# utility methods #
###################


#
# I like die
#
def die(*args)
  errstr = "#$0: FATAL: #{args.join("\n")}"
  errstr << ": #$!" if $!
  errstr.escape_format! if errstr =~ /%/
  at_exit { $stderr.puts errstr }
  exit -1
end

module Path
  #
  # find an application in your $PATH
  #
  def Path::find_app(app)
    ENV['PATH'].split(/:/).find { |path| test ?x, "#{path}/#{app}" }
  end
  
  #
  # Find browser
  #
  def Path::find_browser
    ret = ENV['RAGGLE_BROWSER']
    ret ||= ENV['BROWSER']
    ret ||= %w{links elinks w3m lynx}.find { |app| find_app(app) }

    # die if we couldn't find a browser
    die "Couldn't find suitable browser.",
        "Please set $RAGGLE_BROWSER, $BROWSER, or install one of the following",
        "console browsers: ELinks, Links, Lynx. or W3M." unless ret

    # return browser
    ret
  end
end

# 
# Are we running in a screen session?
#
def in_screen?
  ENV['WINDOW'] != nil
end

#
# get the proxy host and port from ENV['http_proxy']
#
def find_proxy
  ret = [nil, nil]
  ret = [$1, $2] if ENV['http_proxy'] =~ /http:\/\/([^:]+):(\d+)/
  ret
end

class String
  def lines
    self.split(/\n/).size
  end
  
  def escape
    gsub(/(["\\])/, "\\$1")
    self
  end

  def escape!
    gsub!(/(["\\])/, "\\$1")
    self
  end

  def escape_format
    gsub(/%/, '%%')
  end

  def escape_format!
    gsub!(/%/, '%%')
  end

  # this bit of love is from the pickaxe
  def unescape_html
    str = self.dup
    str.gsub!(/&(.*?);/n) {
      m = $1.dup
      case m
      when /^amp$/ni
        '&'
      when /^nbsp$/ni
        ' '
      when /^quot$/ni
        '"'
      when /^lt$/ni
        '<'
      when /^gt$/ni
        '>'
      when /^#8212$/n
        ","
      when /^#8217$/n
        "'"
      when /^#(\d+)$/n
        r = Integer($1)
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      when /^#x([0-9a-f]+)$/ni
        r = $1.hex
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      end
    }
    str
  end

  def strip_tags
    gsub(/<[^>]+?>/, '')
  end

  def reflow(width = 72, force = false, line_delim_regex = %r!^(<br[^/]*>|\.)$!)
    text = ''
    curr_line = ''
    strip.split(/\s+/).each { |word|
      if line_delim_regex && word =~ line_delim_regex
        text << curr_line << "\n" 
        curr_line = ''
      elsif curr_line.length + word.length > width
        if curr_line.length > width and force
          fline = curr_line[0, width - 2] << "\\\n"
          text << fline
          curr_line = curr_line[width - 2, curr_line.length]
        else
          text << curr_line << "\n"
          curr_line = "#{word} "
        end
      else
        curr_line << "#{word} "
      end
    }
    text << curr_line << "\n"
    text
  end
end

module Key
  def Key::scroll_up
    $wins[$a_win].scroll_up
  end

  def Key::scroll_down
    $wins[$a_win].scroll_down
  end

  def Key::scroll_top
    $wins[$a_win].scroll_top
  end

  def Key::scroll_bottom
    $wins[$a_win].scroll_bottom
  end

  def Key::scroll_up_page
    $wins[$a_win].scroll_up_page
  end

  def Key::scroll_down_page
    $wins[$a_win].scroll_down_page
  end

  def Key::quit
    $done = true
  end

  def Key::next_window
    set_active_win(($a_win + 1) % $wins.size)
  end

  def Key::prev_window
    set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
  end

  def Key::select_item
    $wins[$a_win].select_win_item
  end

  def Key::move_item_up
    win = $wins[get_win_id('feed')]
    $a_feed = $config['feeds'].move_up(win.active_item)
    win.move_item_up
  end

  def Key::move_item_down
    win = $wins[get_win_id('feed')]
    $a_feed = $config['feeds'].move_down(win.active_item)
    win.move_item_down
  end

  def Key::delete
    if $config['feeds'].size > 0
      win = $wins[get_win_id('feed')]
      $config['feeds'].delete(win.active_item)
      win.delete_item
      win.active_item = (win.active_item > 0) ? win.active_item - 1 : 0
      win.draw_items
      win.clearrange(win.items.size + 1, win.dimensions[1] - 2)
    end
  end

  def Key::sort_feeds
    win = $wins[get_win_id('feed')]

    # get old active window
    a_win = $a_win

    # sort list, repopulate window
    $config['feeds'].sort
    populate_feed_win
    
    # select first feed, redraw feed window
    win.active_item = 0
    win.draw_items
    win.select_win_item

    # reselect previous window
    set_active_win a_win
  end
  
  def Key::open_link
    win = $wins[get_win_id('desc')]
    win.select_win_item
  end
end

module HTML
  # Tag set defines all tags that the renderer
  # can handle
  #
  # Each tag can modify the context by
  # defining +:context+ key (see pre).
  #
  # Tag's can also have actions which
  # will be executed sequentially when
  # the tag occurs in the token stream.
  # Actions must be defined to occurences
  # of start tags and end tags separately.
  class TagSet
    class Tag
      def initialize
	@context = nil
	@start_actions = []
	@end_actions = []
      end

      attr_accessor :context
      attr_reader :start_actions
      attr_reader :end_actions

      def start_actions=(*actions)
	@start_actions = actions.flatten
      end

      def end_actions=(*actions)
	@end_actions = actions.flatten
      end
    end
    
    def initialize
      @tags = Hash.new
      yield self
    end

    def define_tag(*names)
      yield tag_spec = Tag.new
      names.each do |name|
	yield @tags[name] = tag_spec
      end
    end

    def defined?(name)
      @tags.has_key?(name)
    end
    
    def [](name)
      @tags[name]
    end
  end

  TAG_SET = TagSet.new do |tag_set|
    tag_set.define_tag 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'  do |tag|
      tag.start_actions = :maybe_new_paragraph
      tag.end_actions = :new_paragraph
    end

    tag_set.define_tag 'pre' do |tag|
      tag.context = :in_pre
      tag.start_actions = :maybe_new_paragraph
      tag.end_actions = :new_paragraph
    end

    tag_set.define_tag 'br', 'br/' do |tag|
      tag.start_actions = :force_line_break
    end

    tag_set.define_tag 'a' do |tag|
      tag.start_actions = :save_href
      tag.end_actions = :insert_link_ref
    end
  end

  def self.render_html(source, width=72)
    r = Renderer.new(source, width)
    r.rendered_text
  end
  
  class Renderer
    def initialize(source, width)
      @source, @width = source, width
      @links = []
      @rendered_text = render
    end

    attr_reader :rendered_text
    
    # Execute actions defined for +tag+ in this
    # +phase+.
    #
    # actions:: actions set
    # tag::     tag from tag set
    # phase::   either +:start+ or +:end+
    # params::  params passed to the actions
    def call_actions(tag, phase, *params)
      actions = phase == :start ? tag.start_actions : tag.end_actions
      actions.each do |action|
	self.send("action_#{action}", *params)
      end
    end
    
    # Enter to context defined by tag (if any)
    #
    # context:: current context stack
    # tag::     tag from tag set
    def context_enter(context, tag)
      if tag.context
	context << tag.context
      end
    end
    
    # Exit from context defined by tag (if any)
    #
    # context:: current context stack
    # tag::     tag from tag set
    def context_exit(context, tag)
      if tag.context
	context.pop
      end
    end
    
    # Reflow +text+, and append the result to
    # +lines+
    #
    # lines:: line array representing lines on screen
    # text::  text to be reflown
    # width:: maximum width of each line on screen
    def reflow_text(text)
      cur_line = @lines.pop || ''
      text.split(/\s+/).each do |word|
	if cur_line.length + word.length > @width
	  @lines << cur_line
	  cur_line = ""
	end
	cur_line << " " unless cur_line.empty? || cur_line[-1] == ?\ # fix emacs
	cur_line << word.chomp
      end
      @lines << cur_line
    end
    
    
    # Renders HTML in +src+ to a screen
    # with maximum width +width+. Returns
    # +String+ containing rendered text.
    #
    # src::   HTML source
    # width:: Screen width
    def render
      @lines = []
      @context = []
      
      Parser::each_token(@source) do |token, data, attributes|
	#puts "C: #{context[-1]} T: #{token} D: <#{data}> L: #{lines.inspect}"
	case token
	when :TEXT
	  if @context[-1] == :in_pre
	    @lines.pop if @lines[-1] == ""
	    @lines += data.split("\n", -1)
	  else
	    reflow_text(data)
	  end
	when :START_TAG
	  @current_attributes = attributes
	  tag = TAG_SET[data]
	  next unless tag
	  context_enter(@context, tag)
	  call_actions(tag, :start)
	when :END_TAG
	  tag = TAG_SET[data]
	  next unless tag
	  context_exit(@context, tag)
	  call_actions(tag, :end)
	end
      end

      # trim trailine new lines
      until @lines[-1] != ''
	@lines.delete_at(@lines.size - 1)
      end

      # If there are links, insert the them here
      unless @links.empty?
	@lines << ''
	@lines << $config['msg_links']
	padding = @links.size / 10 + 1
	@links.each_with_index do |link, index|
	  @lines << "%#{padding}d. %s" % [index + 1, link]
	end
      end
      
      rendered_text = @lines.join("\n") + "\n"
      $config['unescape_html'] ? rendered_text.unescape_html : rendered_text
    end

    # Actions used in the tag set

    # Append paragraph break
    def action_new_paragraph
      @lines.push(*['', ''])
    end

    # Append paragraph break, unless there
    # is one already.
    def action_maybe_new_paragraph
      unless @lines[-1] == '' || @lines.empty?
	@lines.push(*['', ''])
      end
    end

    # Force line break.
    def action_force_line_break
      @lines << ''
    end

    # Save href of the current tag (if it exists)
    def action_save_href
      @links << @current_attributes['href']
    end

    # insert reference to the latest link into the
    # rendered text
    def action_insert_link_ref
      @lines[-1] << '[%d]' % @links.size
    end
  end

  module Parser
    NO_ATTRIBUTES = {}.freeze
    ATTRIBUTE_LIST_RE = /\s*([^>=\s]+)\s*(?:=\s*(?:(?:['"]([^'">]*)['"])|([^'"\s>]+)))?/ #'
    PARSER_RE = %r!<(/?\w+[^>]*?/?)>|([^<]*)!m
    
    # Parses tag's attributes and returns them
    # in a hash.
    def self.parse_attributes(source)
      #puts "SOURCE: ", source
      attributes = {}
      source.scan(ATTRIBUTE_LIST_RE) do |name, value, unquoted_value|
	attributes[name] = value || unquoted_value || ''
      end
      attributes
    end
    
    # Parses HTML in +source+ and invokes
    # block with each token as a paramater.
    #
    # Parameters to the block:
    #  token id   | data        | attributes
    #  :TEXT      | text        | NO_ATTRIBUTES
    #  :START_TAG | tag's name  | attributes of current tag
    #  :END_TAG   | tag's name  | NO_ATTRIBUTES
    #
    # source:: HTML source
    def self.each_token(source)
      source.scan(PARSER_RE) do |tag, text|
	#p tag, text
	if tag
	  if tag[0] == ?/
	    yield :END_TAG, tag[1..-1], NO_ATTRIBUTES
	  else
	    if tag =~ /\A(\w+)\s*(.*)\z/m
	      attributes = NO_ATTRIBUTES
	      attributes = parse_attributes($2) if $2
	      yield :START_TAG, $1, attributes
	    end
	  end
	else
	  yield :TEXT, text, NO_ATTRIBUTES unless text == ""
	end
      end
    end
  end
end

# Very simple OPML importer/exporter
module OPML
  # Import OPML file
  # file_name::  OPML file
  # refresh::    refresh rate used for all imported feeds.
  #              If nil, then value of option +feed_default_value+
  #              is used.
  # lock_title:: If true, then all titles of imported feeds
  #              will be locked
  # save_items:: If true, then all imported feeds' items will be saved.
  def OPML::import(file_name, refresh=nil, lock_title=false, save_items=false, force=false)
    refresh = $config['feed_default_refresh'] unless refresh
    feed_list = $config['feeds']

    begin
      doc = File.open(file_name) do |f|
	doc = REXML::Document.new(f)
	doc.root.elements.each('//outline') do |outline|
	  title = outline.attributes['title']
	  url = outline.attributes['xmlUrl']
	  site = outline.attributes['htmlUrl'] || ''
	  desc = outline.attributes['description'] || ''

	  if title.nil? || url.nil?
	    $stderr.puts "Warning: skipping incomplete OPML entry: #{outline}"
	    next
	  end

	  feed_list.add(title, url, refresh, lock_title, save_items, site, desc, [], force)
	end
      end
    rescue REXML::ParseException
      die "Parsing #{file_name} failed: #{$!.message}"
    rescue
      die $!.message
    end
  end


  # Export all feeds to OPML format
  def OPML::export(file_name)
    begin
      feed_list = $config['feeds']

      opml = REXML::Element.new("opml")
      opml.attributes['version'] = '1.1'

      opml.add_element(opml_head)
      
      body = REXML::Element.new('body')
      opml.add_element(body)
      feed_list.each do |feed|
	body.add_element(feed_to_outline(feed))
      end

      doc = REXML::Document.new
      doc << REXML::Document::DECLARATION
      doc.add(opml)

      File.open(file_name, 'w') do |f|
	doc.write(f, 0)
      end
    rescue
      die $!.message
    end
  end

  # Generate OPML header
  def OPML::opml_head
    head = REXML::Element.new('head')
    title = REXML::Element.new('title')
    title.text = 'Raggle subscriptions'
    head.add_element(title)
    head
  end

  # Convert feed hash to outline-element
  def OPML::feed_to_outline(feed)
    outline = REXML::Element.new('outline')
    outline.attributes['title'] = feed['title'] || ''
    outline.attributes['description'] = feed['desc'] || ''
    outline.attributes['xmlUrl'] = feed['url'] || ''
    outline.attributes['htmlUrl'] = feed['site'] if feed.has_key?('site')
    outline.attributes['version'] = 'RSS'
    outline.attributes['type'] = 'rss'
    outline
  end
end

class FeedList
  attr_accessor :feeds
  def initialize
    @feeds = []
  end

  def size
    @feeds.size
  end
  
  def add(title, url, refresh, lock_title=false, save_items=false, site='',
          desc='', items=[], force=true)
    refresh_interval_check(refresh) unless force
    lock_title = false if !lock_title
    save_items = false if !save_items
    @feeds << {
      'title'   => title,
      'url'     => url,
      'refresh' => refresh,
      'site'    => site,
      'desc'    => desc,
      'updated' => 0,
      'items'   => items,
      'lock_title?' => lock_title,
      'save_items?' => save_items,
    }
  end

  def <<(feed)
    @feeds << feed
  end

  def [](*n)
    @feeds[*n]
  end
  
  def get(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds[id]
  end
  
  def delete(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds.delete_at(id)
  end

  def invalidate(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds[id]['updated'] = 0
  end

  def each_with_index
    @feeds.each_with_index { |feed, i| yield feed, i }
  end

  def each
    @feeds.each { |feed| yield feed }
  end

  def each_index
    @feeds.each_index { |i| yield i }
  end

  #
  # Sort feeds by title (case-insensitive).
  #
  def sort
    @feeds.sort! { |a, b|
      a['title'].downcase <=> b['title'].downcase
    }
  end

  def edit(id, opts)
    die "Invalid feed id: #{id}" unless id < @feeds.size
    refresh_interval_check opts['refresh'] if !opts['force'] &&
                                              opts.has_key?('refresh')
    ourl = $config['feeds'].get(id)['url']
    %w{title url refresh lock_title? save_items?}.each { |key|
      $config['feeds'].get(id)[key] = opts[key] if opts.has_key? key
    }
    if opts.has_key?('url') and opts['url'] != ourl
      $config['feeds'].invalidate(id)
    end
  end

  def move_up(id)
    if id > 0
      pitem = @feeds[id - 1]
      @feeds[id - 1] = @feeds[id]
      @feeds[id] = pitem
      id - 1
    else
      id
    end
  end

  def move_down(id)
    if id < @feeds.size - 1
      nitem = @feeds[id + 1]
      @feeds[id + 1] = @feeds[id]
      @feeds[id] = nitem
      id + 1
    else
      id
    end
  end

  def describe(id)
    # clear desc window
    win = $wins[get_win_id('desc')]
    win.clear
    
    win.items = [ ] # This should only ever have one entry
    win.items << {
      'real_title' => $config['feeds'][id]['title'],
      'title'      => $config['feeds'][id]['desc'],
      'date'       => $config['feeds'][id]['date'],
      'url'        => $config['feeds'][id]['url'],
      'date'       => $config['feeds'][id]['updated'].to_s,
      'read?'      => false
    }

    win.draw_items
  end
    
  
  def refresh_interval_check(interval)
    if interval > 0 && interval < $config['feed_refresh_warn']
        err = <<ENDWARNING
Using a refresh interval of less than #{$config['feed_refresh_warn']} minutes
_really_ irritates some system administrators.  If you're sure you want to do
this, use the '--force' option to bypass this warning.
ENDWARNING
# '
      $stderr.puts err.reflow
      exit -1
    end
  end
  private :refresh_interval_check
end

module Feed
  # Feed::Item struct definition
  Item = Struct.new :title, :link, :desc, :date

  #
  # Return the contents of a URL
  #
  def Feed::get_url(url)
    port = 80
    use_ssl = false

    # work with a copy of the url
    url = url.dup

    # check for ssl
    if url =~ /^https:/
      raise 'HTTPS support requires OpenSSL-Ruby' unless $HAVE_SSL
      use_ssl = true
    end

    # strip 'http://' prefix from URL
    url.gsub!(/^\w+?:\/\//, '') if url =~ /^\w+?:\/\//

    # get host and path portions of url
    raise "Couldn't parse URL: \"#{url}\"" unless url =~ /^(.+?)\/(.*)$/
    host, path = $1, $2

    # check for port in URL
    if host =~ /:(\d+)$/
      port = $1.to_i
      host.gsub!(/:(\d+)$/, '')
    end

    # initialize http connection
    http = Net::HTTP.start(host, port)
    http.use_ssl = use_ssl if $HAVE_SSL
    raise "Couldn't connect to host \"#{host}:#{port}\"" unless http

    # get result
    resp, ret = nil, ''
    begin
      resp, ret = http.get('/' << path)
    rescue 
      resp = $!.response

      # handle redirects
      if resp.code =~ /3\d{2}/
        ret = get_url resp['Location']
      else
        raise "HTTP Error: #$!"
      end
    ensure
      # close HTTP connection
      # Note: if we don't specify this, then the connection is pooled
      # for the HTTP/1.1 spec (do we prefer that kind of behavior?
      # maybe I should make in an option)
      http.finish 
    end

    # return URL content
    ret
  end


  class Channel
    attr_accessor :title, :link, :desc, :lang, :items

    def initialize(url)
      parse_rss_url url
    end

    # 
    # Parse an RSS URL and return a FeedChannel object (which contains,
    # among other things, an array of feed_item structs)
    #
    def parse_rss_url(url)
      begin
        content = Feed::get_url url
      rescue
        raise "Couldn't get URL \"#{url}\": #$!."
      end

      # parse URL content
      doc = REXML::Document.new content

      # get channel info
      e = nil
      @title = e.text if e = doc.root.elements['//channel/title']
      @link = e.text if e = doc.root.elements['//channel/link']
      @desc = e.text if e = doc.root.elements['//channel/description']
      @lang = e.text if e = doc.root.elements['//channel/language']
  
      # build list of feed items
      @items = []
      doc.root.elements.each('//item') { |e| 
        # get item attributes (the ones that are set, anyway... stupid
        # RSS)
        h = {}
        [ 'title', 'link', 'date', 'description' ].each { |val|
          h[val] = (t_e = e.elements[val]) ? t_e.text : ''
        }

        h['description'] = find_description(e)

        # insert new item
        @items << Feed::Item.new(h['title'], h['link'],
                                 h['description'], h['date'])
      }
    end

    def find_description(elem)
      $config['desc_element_xpaths'].each { |xpath|
        e = elem.elements[xpath]
        return e.text if e
      }
      ''
    end
  end
end


class Window
  attr_accessor :win, :title, :key, :colors, :active, :items, :active_item,
    :offset

  #
  # window constructor
  #
  def initialize(opts)
    coords = opts['coords'].dup
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    @active_item = 0
    @offset = 0
    @items = []

    @title = opts['title']
    
    @key = opts['key']
    @colors = opts['colors'].dup

    @win = Ncurses::newwin coords[3], coords[2], coords[1], coords[0]
    refresh
  end

  def clearrange(start, fini)
    w = dimensions[0]
    @win.color_set @colors['text'], nil
    start.upto(fini) do |line|
      Ncurses::mvwprintw @win, line, 1, ' ' * (w - 2)
    end
    @win.refresh
  end
  
  #
  # refresh window title and border (but not the contents)
  # 
  def refresh(refresh_contents = false)
    win.color_set @colors[@active ? 'a_box' : 'box'], nil
    Ncurses::box win, 0, 0
    win.color_set @colors[@active ? 'a_title' : 'title'], nil
    Ncurses::mvwprintw win, 0, 1, " #{@title.escape_format} "
    win.color_set @colors['text'], nil
    Ncurses::wrefresh @win
  end

  #
  # clear window contents
  #
  def clear
    @win.color_set @colors['text'], nil
    h = dimensions[1]
    clearrange(1, h - 2)
  end

  def draw_text(text, x, y, reflow, offset)
    if text && text.size > 0
      w,h = dimensions
      i = 0

      text = reflow_string text if reflow
      text.each_line do |line|
        i += 1
        if i >= offset && y < (h - 1)
          Ncurses::mvwprintw @win, y, x,
                             line.escape_format.slice(0, w - x - 1)
          y += 1
        end
      end
    end
  end

  #
  # draw text in window
  #
  def draw(text, x = 1, y = 1, color = 'text', refresh_win = true,
           reflow_text = true, offset = 0)
    w, h = dimensions

    # handle color
    col = @colors[color]
    col_ary = []
    if col.is_a? Array
      col_ary = col
      col = col_ary[0]
      col_ary.each_index { |i|
        @win.attron $config['attr_palette'][col_ary[i]] if i > 0
      }
    end

    # draw text in window
    @win.color_set col, nil if color != 'text'

    draw_text(text, x, y, reflow_text, offset)

    # get default color, attributes
    col = @colors['text']
    col_ary = []
    if col.is_a? Array
      col_ary = col.dup
      col = col_ary[0]
    end

    # set back to default color
    @win.color_set col, nil
    @win.attrset Ncurses::A_NORMAL

    refresh if refresh_win
    y 
  end

  # get window width and height
  def dimensions
    ha = []; wa = []
    Ncurses::getmaxyx @win, ha, wa
    [wa[0], ha[0]]
  end

  #
  # select currently highlighted window item
  #
  # XXX: This really should be split between the window classes as
  #      Appropriate -- richlowe 2003-06-23
  def select_win_item
    if @items && @items.size > 0
      if @items[@active_item].has_key? 'feed'
        select_feed @items[@active_item]['feed']
      elsif @items[@active_item].has_key? 'item'
        select_item @items[@active_item]['item']
      elsif @items[@active_item].has_key? 'url'
        # are we opening new screen windows?
        use_screen = $config['use_screen'] && in_screen?

        # drop out of curses mode
        save_screen unless use_screen

        # get browser command
        cmd = $config['browser_cmd'] % @items[@active_item]['url'].escape

        # prepend screen command if we're using it
        if use_screen
          screen_cmd = if $config['screen_cmd'] =~ /%s/
            $config['screen_cmd'] % @items[@active_item]['real_title']
          else
            $config['screen_cmd']
          end

          # build new command
          cmd = screen_cmd << ' ' << cmd
        end

        if cmd =~ $config['shell_meta_regex'] and !$config['force_url_meta']
          Ncurses::beep
          set_status "Refusing to open link containing meta-characters"
        else
          # execute command
          system cmd
        end

        # reset screen
        restore_screen unless use_screen
      end
    end
  end

  def reflow_string(str)
    w = dimensions[0]
    str.reflow(w - 4)
  end
  
  def method_missing(id)
    raise "Please implement #{self.class}##{id.id2name}"
  end
end
  
class ListWindow < Window
  #
  # redraw window items
  #
  def draw_items
    y = 0
    w, h = dimensions
    ic = 0
    @items.each { |i| 
      t = i['title'].strip_tags || ''
      text = t + ((t.length < w) ? (' ' * (w - t.length)) : '')
      if i.has_key?('item_count') && i['item_count'] == 0 &&
          i['updated'] > 0
        color = (ic == @active_item) ? 'h_empty' : 'empty'
      elsif i.has_key?('read?') && i['read?'] == false
        color = (ic == @active_item) ? 'h_unread' : 'unread'
      else
        color = (ic == @active_item) ? 'h_text' : 'text'
      end
      draw(text, 1, y += 1, color, true, false) if ic >= @offset
      ic += 1
    }
    clearrange(items.size + 1, h - 2)
  end
  
  #
  # Adjust the window to show the selected item
  #
  def adjust_to(item)
    # scroll window (if necessary)
    w, h = dimensions
    if item < @offset || item >= @offset + (h - 3)
      @offset = @active_item
      @offset = 0 if @offset < 0
      if item + h - 3 > @items.size - 1
        @offset = @active_item - (h - 3)
        @offset = 0 if @offset < 0
      end
    end
    draw_items

    if $config['describe_hilited_feed'] == true &&
        @items[item].has_key?('feed')
      $config['feeds'].describe(item)
    end
    
    status = ' ' << @items[@active_item]['title']
    status = status.split(/\s+/).join(' ')
    set_status status

    select_win_item if $config['focus'] == 'auto'
  end
  private :adjust_to

  #
  # Activate an item
  #
  def activate(item)
    if @items.size > 0
      if item >= @items.size or item < 0
        throw "Window#activate item out of range (#{item}/#{@items.size})"
      end
      @active_item = item
      adjust_to item
    end
  end
  
  def scroll_up_page
    if $config['page_step'] < 0
      w,h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end
      
    pos = @active_item - step
    pos < 0 ? activate(0) : activate(pos)
  end

  #
  # Scroll one page down.
  #
  def scroll_down_page
    if $config['page_step'] < 0
      w,h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    pos = @active_item + step
    pos >= @items.size ? activate(@items.size - 1) : activate(pos)
  end
       
  #
  # Bound scrolling based on $config['scroll_wrapping']
  #
  def scroll_bound(point)
    if point >= @items.size
      $config['scroll_wrapping'] ? 0 : @items.size - 1
    elsif point < 0
      $config['scroll_wrapping'] ? @items.size - 1 : 0
    else
      point
    end
  end

  #
  # Scroll the window up one item
  #
  def scroll_up
      activate scroll_bound(@active_item - 1)
  end
  
  #
  # Scroll window down.
  #
  def scroll_down
      activate scroll_bound(@active_item + 1)
  end
  
  #
  # Scroll to the bottom.
  #
  def scroll_bottom
    activate @items.size - 1
  end

  #
  # Scroll to the top item
  #
  def scroll_top
    activate 0
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end
end

class TextWindow < Window
  def reflow_string(str)
    w = dimensions[0]
    HTML.render_html(str, w - 4)
  end
       
  def draw_items
    item = @items[0] # There can be only one
    y = 1
    h = dimensions[1]

    if item['real_title'] && item['real_title'] != ''
      draw(item['real_title'].strip, 1, y, 'f_title', true, false)
      y += 1
    end
    draw("Link: ", 1, y)
    # @win.color_set @colors['url'], nil
    draw(item['url'], 7, y, 'url', true, false)

    # don't draw the date if it isn't set (silly RSS)
    if item['date'] && item['date'] != '' && item['date'] != "0"
      y += 1
      draw("Date: ", 1, y)
      
      # handle date string shenanigans
      if ((i_val = item['date'].to_i) > 0)
        d_str = Time.at(i_val).strftime($config['desc_date_format'])
      else
        d_str = item['date']
      end
      
      # draw date string
      # @win.color_set @colors['date'], nil
      draw(d_str, 7, y, 'date', true, false)
    end
    if item['title']
      y += 2
      str = item['title'] || ''
      str = str.strip_tags if $config['strip_html_tags']
     
      # Offset + 1, so we scroll on the *first* press
      draw(str, 1, y, 'text', true, true, @offset + 1)
      y += (reflow_string(str).lines - @offset)
    end

    # *Much* faster than a total clear each time it scrolls.
    clearrange(y, h - 2)
    
    refresh(true)
  end

  def scroll_up_page
    if $config['page_step'] < 0
      w, h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    @offset = @offset - step
    draw_items
  end

  def scroll_down_page
    if $config['page_step'] < 0
      w, h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    @offset = @offset + step
    draw_items
  end
  
  def scroll_up
    @offset -= 1 if @offset > 0
    draw_items
  end

  def scroll_down
    # This is a *terrible* way to figure out how many lines of text we'll end
    # up with.., XXX put me somewhere better.
    s = reflow_string(@items[0]['title']).lines
    @offset += 1 if @offset < s - 1
    draw_items
  end

  def scroll_bottom
    # This is a *terrible* way to figure out how many lines of text we'll end
    # up with.., XXX put me somewhere better.
    h,s = dimensions[1], 0

    %w{real_title url date}.each do |key|
      s += 1 if @items[0].has_key?(key)
    end
    s += reflow_string(@items[0]['title']).lines + 1
    @offset = s - (h - 2)
    draw_items
  end

  def scroll_top
    @offset = 0
    draw_items
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end

  def resize_width
    # XXX
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end

  def resize_width
    # XXX
  end
end

#
# set status bar message
#
def set_status(str)
  str ||= ''

  w, e_msg = $config['w'], $config['msg_exit']
  $status, $new_status = str, str

  # fix message length
  if str.length > (w - e_msg.length)
    str = str.slice(0, w - e_msg.length)
  else
    str += ' ' * (w - e_msg.length - str.length)
  end
  msg = str << e_msg

  Ncurses::stdscr.color_set $config['theme']['status_bar_cols'], nil
  Ncurses::mvprintw $config['h'], 0, msg.escape_format
  Ncurses::refresh
end

# 
# set active window 
#
def set_active_win(a_win)
  $wins[$a_win].active = false
  $wins[$a_win].refresh

  $a_win = a_win

  $wins[$a_win].active = true
  $wins[$a_win].refresh
end

#
# get window id by key
#
def get_win_id(str)
  $wins.each_index { |i| return i if $wins[i].key == str }
  -1
end


# 
# expand path macros in $config
#
def expand_config
  $config.each { |key, val| 
    next unless val.class == String && val =~ /\${(.+?)}/
    orig_val = val.dup
    val.gsub!(/\${(.+?)}/, $config[$1])
    # puts "\"#{orig_val}\" expands to \"#{val}\""
  }
end

#
# describe the highlighted feed
# 
def describe_feed(id)
  d_win = $wins[get_win_id('desc')]
  d_win.active_item = 0
  d_win.items.clear
  d_win.clear

  y = 0
  feed = $config['feeds'].get(id)

  # print title
  str = feed['title'].strip
  d_win.draw(str, 1, y += 1, 'f_title')

  # print last update
  if feed.has_key?('updated') && feed['updated'] > 0
    if feed['updated'].is_a? Fixnum
      date_str = Time.at(feed['updated']).to_s
    else
      date_str = 'never'
    end

    str = 'Updated: ' << date_str
    d_win.draw(str, 1, y += 1, 'f_update')
  end
  
  # print site url
  if $config['desc_show_site'] &&
     feed.has_key?('site') && feed['site'].length > 0
    str = feed['site']
    d_win.draw(str, 1, y += 1, 'f_site')
  end

  # print site url
  if $config['desc_show_url'] &&
     feed.has_key?('site') && feed['site'].length > 0
    str = feed['url']
    d_win.draw(str, 1, y += 1, 'f_url')
  end

  # draw poor man's divider
  if $config['desc_show_divider']
    d_win.draw('-  ' * 100, 1, y += 2, 'box', true, false)
  end

  # print error
  if feed.has_key?('error')
    d_win.draw(feed['error'], 1, y += 2, 'f_error')
  else 
    # print description
    if feed['desc'] && feed['desc'].length > 0
      str = feed['desc']
      d_win.draw(str, 1, y += 2, 'f_desc')
    end
  end
  
  # refresh window
  d_win.refresh
end

#
# set active feed by id
#
def select_feed(id)
  $a_feed = id
  $a_item = 0

  # clear item window
  item_win = $wins[get_win_id('item')]
  item_win.offset = 0
  item_win.active_item = 0
  item_win.items.clear

  $wins[get_win_id('desc')].offset = 0
  
  # unused.. remove it?
  fmt = $config['item_date_format']

  # wtf is happening here?
  raise "id.class.to_s = #{id.class.to_s}" unless id.class == Fixnum
  
  # iterate through feed items
  $config['feeds'].get(id)['items'].each_with_index { |item, i|
    # can't depend on the date being in a consistent format, or
    # being defined at all, for that matter :( :( :(
    # title = item['title'] + ' (' +
    #         Time.at(item['date'].to_i).strftime(fmt) << ')'

    # build title string
    if item['date'] && item['date'].size > 0
      d_str = item['date']
      d_str = Time.at(item['date'].to_i).strftime(fmt) if item['date'].to_i > 0
      title = "#{item['title']} (#{d_str})"
    elsif item['title'] !~ /^\s*$/ 
      title = item['title'] ? item['title'].strip : ''
    elsif item['desc'] !~ /^\s*$/ 
      # fall back on cleaned up and truncated description if we're
      # missing a title
      w, h = item_win.dimensions
      title = item['desc'].strip.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    else
      # if title is garbage and we have no description, then fall back
      # on formatted and truncated link (silly broken RSS feeds)
      title = '[' << item['url'].strip << ']'

      w, h = item_win.dimensions
      title = title.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    end

    item_win.items << {
      'title' => title,
      'item'  => i,
      'read?' => item['read?']
    }
  }

  # redraw item window
  item_win.draw_items

  $config['feeds'].describe($a_feed)
  
  # activate item window
  set_active_win(get_win_id('item')) if $config['focus'] == 'select'
end

#
# populate feed window
# 
def populate_feed_win 
  win = $wins[get_win_id('feed')]

  win.items.clear
  
  $config['feeds'].each_with_index { |feed, i|
    # count unread items
    unread_count = 0
    feed['items'].each { |item| unread_count += 1 unless item['read?'] }

    # build title
    title = feed['title'].strip << " (#{unread_count}/#{feed['items'].size})"
    win.items << {
      'title'       => title,
      'feed'        => i,
      'read?'       => unread_count == 0,
      'item_count'  => feed['items'].size,
      'updated'     => feed['updated'],
    }
  }
  win.draw_items
end

#
# set active item by id
#
def select_item(id)
  $a_item = id

  desc_win = $wins[get_win_id('desc')]
  item_win = $wins[get_win_id('item')]

  # clear description window
  desc_win.active_item = 0
  desc_win.items.clear

  # mark item as read
  item_win.items[$a_item]['read?'] = true
  $config['feeds'].get($a_feed)['items'][id]['read?'] = true

  desc_win.offset = 0
  
  # load item
  desc_win.items << {
    'title'       => $config['feeds'].get($a_feed)['items'][id]['desc'],
    'real_title'  => $config['feeds'].get($a_feed)['items'][id]['title'],
    'url'         => $config['feeds'].get($a_feed)['items'][id]['url'],
    'date'        => $config['feeds'].get($a_feed)['items'][id]['date'],
    'read?'       => $config['feeds'].get($a_feed)['items'][id]['read?'],
  }

  # redraw feed window
  populate_feed_win

  # redraw description window
  desc_win.win.clear
  desc_win.draw_items

  # activate description window
  set_active_win(get_win_id('desc')) if $config['focus'] == 'select' and
                                       !$config['no_desc_auto_focus']
end

#
# mark all items in feed as read
# 
def mark_items_as_read
  win = $wins[get_win_id('item')]
  # mark item as read
  win.items.each { |item| item['read?'] = true }
  $config['feeds'].get($a_feed)['items'].each { |item| item['read?'] = true }

  populate_feed_win
  win.draw_items
end

DIRECTION_BACKWARD = -1
DIRECTION_FORWARD = 1

#
# Select next unread item in
# direction +direction+. Direction
# can be either +DIRECTION_FORWARD+
# or +DIRECTION_BACKWARD+
#
def select_unread_item(direction)
  win = $wins[get_win_id('item')]
  size = win.items.size

  return unless size > 0
  
  i = ($a_item + direction) % size
  while i != $a_item
    if win.items[i]['read?'] == false
      select_item i
      win.activate i
      win.draw_items
      return
    end

    i = (i + direction) % size
  end
end

#
# select next unread item
#
def select_next_unread
  select_unread_item DIRECTION_FORWARD
end

#
# select previous unread item
#
def select_prev_unread
  select_unread_item DIRECTION_BACKWARD
end

#
# load feed cache
#
def load_feed_cache
  set_status "Loading feed cache..."
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config['feeds'].each { |feed|
      feed['items'] = s.root?(feed['url']) ? s[feed['url']] : []
    }
  }
  populate_feed_win
  select_feed 0
  set_active_win get_win_id('feed')
  set_status "Loading feed cache... done"
end

#
# save feed cache 
#
def save_feed_cache
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config['feeds'].each { |feed| s[feed['url']] = feed['items'] }
  }
end

#
# save feed list 
#
def save_feed_list
  File::open($config['feed_list_path'], 'w') { |f|
    $stdout.puts $config['msg_save_list'] if $config['raggle_mode'] == 'view'
    $stdout.flush
    $config['feeds'].each { |feed| feed['items'].clear }
    f.puts $config['feeds'].to_yaml
  }
end

#
# save theme
#
def save_theme
  File::open($config['theme_path'], 'w') { |f|
    $stdout.puts $config['msg_save_theme']
    $stdout.flush
    f.puts $config['theme'].to_yaml
  }
end

#
# handle mouse events
#
def handle_mouse(ev) 
  puts 'mouse'
end

def print_usage
  puts <<ENDUSAGE
Raggle - Console RSS feed aggregator.
Version #$VERSION, by Paul Duncan <pabs@pablotron.org> and
                      Richard Lowe <richlowe@richlowe.net>

Usage:
  #$0 [options]

Options:
  -a, --add, --add-feed         Add a new feed (requires '--title', '--url',
                                and '--refresh').
  -c, --config                  Specify an alternate config file.
  -d, --delete, --delete-feed   Delete an existing feed.
  -e, --edit, --edit-feed       Edit an existing feed.
  --export-opml                 Export feeds to OPML.  
  --force                       Force behavior Raggle won't normally allow.
                                Use this option with caution.
  -h, --help, --usage           Display this usage screen.
  --import-opml                 Import feeds from an OPML file.
  -i, --invalidate              Invalidate a feed (force an update).
  -l, --list                    List existing feeds (use '--verbose' to 
                                show URLs as well).
  --lock-title                  Lock Title attribute of feed (for '--add'
                                and '--edit').
  --purge                       Purge deleted feeds from feed cache.
  -r, --refresh                 Refresh attribute of feed (for '--add' and
                                '--edit').
  --save-items                  Save old items of feed (for '--add' and
                                '--edit').
  --sort, --sort-feeds          Sort feeds by title (case-insensitive).
  -t, --title                   Title attribute of feed (for '--add' and
                                '--edit').
  --unlock-title                Unlock Title attribute of feed (for '--add'
                                and '--edit').
  --unsave-items                Don't save old items of feed (for '--add'
                                and '--edit').
  -u, --url                     URL attribute of feed (for '--add' and
                                '--edit').
  --verbose                     Turn on verbose output.
  -v, --version                 Display version information.

Examples:
  # add a new feed, refresh every 30 minutes
  #$0 -a -t 'test feed' -u http://www.example.com/feed.rss -r 30

  # list feeds and their ids
  #$0 --list

  # delete an existing feed
  #$0 --delete 12

  # set the title and refresh of an existing feed
  #$0 --edit 10 --title 'hi there!' -r 20

  # set and lock the title of feed 12
  #$0 -e 12 -t 'short title' --lock-title
  
About the Authors:
Paul Duncan <pabs@pablotron.org>
http://www.pablotron.org/

Richard Lowe <richlowe@richlowe.net>
http://www.richlowe.net/
ENDUSAGE

  exit(0)
end

#
# handle command-line options
# 
def handle_command_line(opts)
  ret = { 'mode' => 'view' }

  gopts = GetoptLong.new(
    ['--add', '-a',        '--add-feed',        GetoptLong::NO_ARGUMENT],
    ['--edit', '-e',       '--edit-feed',       GetoptLong::REQUIRED_ARGUMENT],
    ['--delete', '-d',     '--delete-feed',     GetoptLong::REQUIRED_ARGUMENT],
    ['--invalidate', '-i', '--invalidate-feed', GetoptLong::REQUIRED_ARGUMENT],
    ['--config', '-c',     '--config-file',     GetoptLong::REQUIRED_ARGUMENT],
    ['--force',                                 GetoptLong::NO_ARGUMENT],		 
    ['--list', '-l',                            GetoptLong::NO_ARGUMENT],
    ['--title', '-t',                           GetoptLong::REQUIRED_ARGUMENT],
    ['--url', '-u',                             GetoptLong::REQUIRED_ARGUMENT],
    ['--refresh', '-r',                         GetoptLong::REQUIRED_ARGUMENT],
    ['--version', '-v',                         GetoptLong::NO_ARGUMENT],
    ['--purge',                                 GetoptLong::NO_ARGUMENT],
    ['--sort', '--sort-feeds',                  GetoptLong::NO_ARGUMENT],
    ['--lock-title',                            GetoptLong::NO_ARGUMENT],
    ['--unlock-title',                          GetoptLong::NO_ARGUMENT],
    ['--save-items',                            GetoptLong::NO_ARGUMENT],
    ['--unsave-items',                          GetoptLong::NO_ARGUMENT],
    ['--verbose',                               GetoptLong::NO_ARGUMENT],
    ['--import-opml',                           GetoptLong::REQUIRED_ARGUMENT],
    ['--export-opml',                           GetoptLong::REQUIRED_ARGUMENT],
    ['--diag',                                  GetoptLong::NO_ARGUMENT],
    ['--help', '-h', '--usage',                 GetoptLong::NO_ARGUMENT]
  )

  begin
    gopts.each do |opt, arg|
      case opt
        when '--add'
          ret['mode'] = 'add'
        when '--edit'
          ret['mode'] = 'edit'
          ret['id'] = arg.to_i
        when'--delete'
          ret['mode'] = 'delete'
          ret['id'] = arg.to_i
        when '--invalidate'
          ret['mode'] = 'invalidate'
          ret['id'] = arg.to_i
        when '--config'
          $config['config_path'] = arg
        when '--force'
	  ret['force'] = true
        when '--list'
          ret['mode'] = 'list'
        when '--title'
          ret['title'] = arg
        when '--url'
          ret['url'] = arg
        when '--refresh'
          ret['refresh'] = arg.to_i
        when '--version'
          puts "Raggle v#$VERSION"
          exit 0
        when '--purge'
          ret['mode'] = 'purge'
        when '--sort', '--sort-feeds'
          ret['mode'] = 'sort'
        when '--lock-title'
          ret['lock_title?'] = true
        when '--unlock-title'
          ret['lock_title?'] = false
        when '--save-items'
          ret['save_items?'] = true
        when '--unsave-items'
          ret['save_items?'] = false
        when '--verbose'
          $config['verbose'] = true
        when '--import-opml'
          ret['mode'] = 'import_opml'
          ret['opml_file'] = arg
        when '--export-opml'
          ret['mode'] = 'export_opml'
          ret['opml_file'] = arg
        when '--diag'
          $config['diag'] = true
        when '-h', '--help', '--usage'
          print_usage
      end
    end
  rescue GetoptLong::InvalidOption 
    exit -1
  end

       
  # check options
  if ret['mode'] == 'add'
    ['title', 'url', 'refresh'].each { |val|
      unless ret[val]
        die "Missing '--#{val}'."
        exit -1
      end
    }
  elsif ret['mode'] == 'edit'
    unless ret['title'] || ret['url'] || ret['refresh'] ||
           ret.has_key?('lock_title?') || ret.has_key?('save_items?')
      die "Please specify a feed change to make."
    end
  end

  # return options
  ret
end

#
# print a list of feeds to stdout
#
def list_feeds
  i = -1
  if $config['verbose']
    puts 'ID, Title, URL, Refresh'
    $config['feeds'].each { |feed|
      title = feed['title'].escape_format
      url = feed['url'].escape_format
      puts "%2d, #{title}, #{url}, #{feed['refresh']}" % (i += 1)
    }
  else 
    puts 'ID, Title'
    $config['feeds'].each { |feed|
      title = feed['title'].escape_format
      puts "%2d, #{title}" % (i += 1)
    }
  end
end

#
# add a new feed
#
def add_feed(opts)
    $config['feeds'].add(opts['title'], opts['url'], opts['refresh'],
                         opts['lock_title?'], opts['save_items?'],
			 '', '', [], opts['force'])
end

#
# purge extra feeds in cache
#
def purge_feed_cache
  urls = {}
  $config['feeds'].each { |feed| urls[feed['url']] = true }
  PStore::new($config['feed_cache_path']) { |cache|
    cache.roots.each { |root| 
      unless urls[root]
        $stderr.puts "Purging \"#{root}\"" if $config['verbose']
        cache[root] = nil
      end
    }
  }
end

# 
# delete a feed by id
#
def delete_feed(id)
  $config['feeds'].delete(id)
end

#
# Invalidate a feed by id
#
def invalidate_feed(id)
  $config['feeds'].invalidate(id)
end

#
# Sort feeds 
#
def sort_feeds
  $config['feeds'].sort
end

#
# edit an existing feed
#
def edit_feed(id, opts)
  $config['feeds'].edit(id, opts)
end

# 
# create a lock file for raggle
#
def create_cache_lock
  path = $config['cache_lock_path']
  
  # open cache lock for writing
  unless $config['cache_lock'] = File::open(path, 'w')
    die "Couldn't open \"#{path}\"."
  end

  # obtain cache lock
  unless $config['cache_lock'].flock(File::LOCK_EX | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't obtain cache lock: " << 
                 "Another instance of Raggle is running.\n"
    $stderr.puts "WARNING: Disabling feed caching for this instance."
    $stderr.puts "WARNING: Press enter to continue."

    # wait for user response
    $stdin.gets

    # disable feed caching and theme saving
    $config['use_cache_lock'] = false
    $config['save_feed_list'] = false
    $config['save_feed_cache'] = false
    $config['save_theme'] = false
  end
end

#
# destroy raggle lock file
#
def destroy_cache_lock
  path = $config['cache_lock_path']

  # unlock cache lock
  unless $config['cache_lock'].flock(File::LOCK_UN | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end

  # close cache lock
  $config['cache_lock'].flush
  $config['cache_lock'].close
  $config['cache_lock'] = nil

  # start garbage collection (flush out file descriptor)
  GC.start

  # unlink cache lock
  unless File::unlink(path)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end
end


def resize_term
  # get screen coordinates
  h = []; w = []
  Ncurses::getmaxyx Ncurses::stdscr, h, w
  $config['w'] = w[0]
  $config['h'] = h[0] - 1

  # resize each window
  $config['theme']['window_order'].each { |key|
    win = $wins[get_win_id(key)]

    # determine new coordinates
    coords = $config['theme']['win_' << key]['coords'].dup
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    # delete old window, create new one
    win.win.del
    win.win = Ncurses::newwin coords[3], coords[2],
                              coords[1], coords[0]

    # refresh window
    win.refresh
    win.draw_items
  }

  set_status " #{$config['msg_term_resize']}#{w[0]}x#{h[0]}"

  # refresh full screen
  Ncurses::refresh
end

#
# save screen mode, drop out of ncurses
#
def save_screen
  Ncurses::def_prog_mode
  Ncurses::endwin
end

#
# restore saved screen settings
#
def restore_screen
  Ncurses::reset_prog_mode
  Ncurses::refresh
  # Ncurses::getch
end

#
# drop to sub-shell
#
def drop_to_shell
  save_screen
  system ENV['SHELL']
  restore_screen
end

#######################################################################
# End Shenanigans, Begin Actual Code                                  #
#######################################################################

##
# Ugly
# -- richlowe 2003-07-01
def setup_win
      # initialize screen & keyboard
    Ncurses::initscr
    Ncurses::raw if $config['use_raw_mode']
    Ncurses::keypad Ncurses::stdscr, 1
    Ncurses::noecho if $config['use_noecho']
    Ncurses::start_color
    # Ncurses::mousemask(Ncurses::ALL_MOUSE_EVENTS, [])
    
    # exit -1 unless Ncurses::has_colors?
    
    # initialize color pairs
    $config['color_palette'].each { |ary| Ncurses::init_pair *ary }
    
    # get screen coordinates
    h = []; w = []
    Ncurses::getmaxyx Ncurses::stdscr, h, w
    $config['w'] = w[0]
    $config['h'] = h[0] - 1
    
    # draw menu bar
    # c_msg = $config['msg_close']
    # msg = (' ' * ($config['w'] - c_msg.length)) << c_msg
    # Ncurses::wcolor_set Ncurses::stdscr, $config['menu_bar_cols'], nil
    # Ncurses::mvprintw 0, 0, msg.escape_format
    # Ncurses::refresh
    
    # draw status bar
    $new_status = ''
    set_status $config['msg_welcome']
    
    # create windows
    $a_win = 0
    $wins = []
    $config['theme']['window_order'].each { |i|
      case i
        when /feed/
          cl = ListWindow
        when /item/
          cl = ListWindow
        when /desc/
          cl = TextWindow
      else
        raise "Unknown window #{i}"
      end
      $wins << cl.new($config['theme']["win_#{i}"])
      # $wins[-1].draw LONG_STRING
    }
    set_active_win(0)
    
    $a_feed, $a_item = 0, 0
    
    # populate feed window
    populate_feed_win
    
    select_feed(0)
    set_active_win(0)
end

def main
  
  
  # expand the default config hash
  expand_config

  # parse command-line options
  opts = handle_command_line ARGV
  
  # if $HOME/.raggle doesn't exist, then create it
  Dir::mkdir $config['config_dir'] unless test ?d , $config['config_dir']
  
  # load user config ($HOME/.raggle/config.rb)
  puts $config['msg_load_config'] if opts['mode'] == 'view'
  load $config['config_path'], false if test ?e, $config['config_path']
  expand_config
  
  # load feed list
  puts $config['msg_load_list'] if opts['mode'] == 'view'
  if $config['load_feed_list'] && test(?e, $config['feed_list_path'])
    $config['feeds'] = YAML::load(File::open($config['feed_list_path']))
  end

  if $config['feeds'] && $config['feeds'].size == 0
    $config['default_feeds'].each {|feed|
      $config['feeds'].add(feed['title'], feed['url'], feed['refresh'],
                           feed['lock_title?'], feed['save_items?'],
                           feed['site'], feed['desc'], feed['items'])
    }
  end
  
  # create cache lock
  create_cache_lock if $config['use_cache_lock']
  
  # handle command-line options
  $config['raggle_mode'] = opts['mode']
  case opts['mode']
  when 'list'
    list_feeds
    exit 0
  when 'add'
    add_feed opts
    save_feed_list
    exit 0
  when 'delete'
    delete_feed opts['id']
    save_feed_list
    exit 0
  when 'invalidate'
    invalidate_feed opts['id']
    save_feed_list
    exit 0
  when 'edit'
    edit_feed opts['id'], opts
    save_feed_list
    exit 0
  when 'sort'
    sort_feeds
    save_feed_list
    exit 0
  when 'purge'
    purge_feed_cache
    exit 0
  when 'import_opml'
    OPML::import opts['opml_file'], opts['refresh'], opts['lock_title?'], opts['save_items'],
      opts['force']
    save_feed_list
    exit 0
  when 'export_opml'
    OPML::export opts['opml_file']
    exit 0
  end
  

  # load theme
  puts $config['msg_load_theme']
  if $config['load_theme'] && test(?e, $config['theme_path'])
    $config['theme'] = YAML::load(File::open($config['theme_path']))
  end

  # Draw windows and such.
  setup_win
  
  # load feed cache
  load_feed_cache if $config['load_feed_cache'] &&
    test(?e, $config['feed_cache_path'])
  
  # start feed grabbing thread
  feed_thread = Thread.new {
    File.open($config['grab_log_path'], $config['grab_log_mode']) { |log|
      log.puts "#{Time.now}: Starting grab log."
      loop {
        $config['feeds'].each { |feed|
          t = Time.now
          
          $new_status = " Checking feed \"#{feed['title']}\"..."
          log.puts "#{Time.now}: Checking feed \"#{feed['title']}\""
          next unless feed['refresh'] > 0 && 
            feed['updated'] + (feed['refresh'] * 60) < t.to_i
          
          # update statusbar and grab log
          $new_status = " Updating feed \"#{feed['title']}\"..."
          log.puts "#{t}: Updating feed \"#{feed['title']}\" from \"#{feed['url']}\""
          # set_status "Updating \"#{feed['title']}\"..."
          
          # TODO: save old items
          # old_items = feed['items']
          
          # get channel
          begin
            chan = Feed::Channel.new(feed['url'])
            feed.delete 'error'
          rescue
            # set_status "Error updating \"#{feed['title']}\"."
            log.puts "#{t}: Error: #$!"
            feed['error'] = "#$!"
            next
          end
          
          # update feed attributes
          feed['title'] = chan.title unless $config['lock_feed_title'] ||
                                            feed['lock_title?'] == true
          feed['desc'] = chan.desc
          feed['site'] = chan.link
          feed['updated'] = t.to_i
          
          # hash the urls, save the read status
          urls = {}
          feed['items'].each { |item| urls[item['url']] = item['read?'] }

          # clear the list if we're not saving feed items
          feed['items'].clear unless $config['save_feed_items'] ||
                                     feed['save_items?']
          
          # insert new items
          new_items = []
          chan.items.each { |item|
            unless (($config['save_feed_items'] || feed['save_items?']) &&
                    urls.has_key?(item.link))
              was_read = urls.has_key?(item.link) && urls[item.link]
              new_items << {
                'title' => item.title,
                'date'  => item.date,
                'url'   => item.link,
                'desc'  => item.desc,
                'read?' => was_read,
                'added' => Time.now.to_i,
              }
            end
          }
          
          # if we're saving old items, then prepend the new items
          # otherwise, replace the old list
          if $config['save_feed_items'] || feed['save_items?']
            feed['items'] = new_items + feed['items']
          else
            feed['items'] = new_items
          end
          
          # redraw feed / item windows
          $update_wins = true
        }
        
        # finish log entries
        interval = $config['feed_sleep_interval']
        $new_status = $config['msg_grab_done']
        log.puts "#{Time.now}: Done checking.  Sleeping for #{interval}s."
        log.flush
        sleep interval
      }
    }
  }

  begin
    # main input loop
    timeout = $config['input_select_timeout']
    $done = false
    until $done
      # handle keyboard input
      r = select [$stdin], nil, nil, timeout
      if r && r.size > 0
        c = Ncurses::getch
        $config['keys'][c].call($wins[$a_win], c) if $config['keys'].has_key? c
      end
      
      # refresh window contents if there's been a feed update
      if $update_wins
        $update_wins = false
        populate_feed_win
        # wins.each { |win| win.draw_items }
      end
      
      set_status $new_status if $new_status != $status
    end
  ensure
    
    # clean up screen on exit
    Ncurses::endwin
    
    # stop feed grabbing thread
    feed_thread.exit
    
    # save feed cache
    save_feed_cache if $config['save_feed_cache']
    
    # save feed list
    save_feed_list if $config['save_feed_list']
    
    # save theme
    save_theme if $config['save_theme']
    
    # unlock everything
    destroy_cache_lock if $config['use_cache_lock'] && $config['cache_lock']
    
    $stdout.puts $config['msg_thanks']
  end
end

##################
# default config #
##################
$config = {
  'config_dir'            => ENV['HOME'] + '/.raggle',
  'config_path'           => '${config_dir}/config.rb',
  'feed_list_path'        => '${config_dir}/feeds.yaml',
  'feed_cache_path'       => '${config_dir}/feed_cache.store',
  'theme_path'            => '${config_dir}/theme.yaml',
  'grab_log_path'         => '${config_dir}/grab.log',
  'cache_lock_path'       => '${config_dir}/lock',

  # feed list handling
  'load_feed_list'        => true,
  'save_feed_list'        => true,

  # feed cache handling
  'load_feed_cache'       => true,
  'save_feed_cache'       => true,

  # save old feed items indefinitely?
  # Note: doing this with a lot of high-traffic feeds can make
  # your feed cache grow very large, very fast.  It's probably better
  # to use the per-feed --save-items command-line option.
  'save_feed_items'       => false,

  # theme handling
  'load_theme'            => true,
  'save_theme'            => true,

  # feed list, feed cache, and theme lock handling
  'use_cache_lock'        => true,

  # ui options
  'focus'                 => 'select', # ['none', 'select', 'auto']
  'no_desc_auto_focus'    => true,
  'scroll_wrapping'       => true,

  # proxy settings
  'proxy' => {
    'host'  => find_proxy[0],
    'port'  => find_proxy[1],
  },

  # Number of list items per "page" (wrt page up/down)
  # (if < 0, then the height of the window, minus N items)
  'page_step'             => -3,

  # date formats
  'item_date_format'      => '%c',
  'desc_date_format'      => '%c',

  # messages
  'msg_welcome'           => " Welcome to Raggle #{$VERSION}.",
  'msg_exit'              => "| Press Q to exit ",
  'msg_close'             => '[X] ',
  'msg_grab_done'         => " Raggle #{$VERSION}",
  'msg_load_config'       => 'Raggle: Loading config...',
  'msg_load_list'         => 'Raggle: Loading feed list...',
  'msg_save_list'         => 'Raggle: Saving feed list...',
  'msg_load_cache'        => 'Raggle: Loading feed cache...',
  'msg_save_cache'        => 'Raggle: Saving feed cache...',
  'msg_load_theme'        => 'Raggle: Loading theme...',
  'msg_save_theme'        => 'Raggle: Saving theme...',
  'msg_thanks'            => 'Thanks for using Raggle!',
  'msg_term_resize'       => 'Terminal Resize: ',
  'msg_links'             => 'Links:',

  # menu bar color
  'menu_bar_cols'         => 24,

  # input select timeout (in seconds)
  'input_select_timeout'  => 0.2,

  # feed sleep interval (in seconds)
  'feed_sleep_interval'   => 60,

  # grab log mode (a == append, w == write)
  'grab_log_mode'         => 'w',

  # strip html from item contents?
  'strip_html_tags'       => false,

  # decode html escape sequences?
  'unescape_html'         => true,

  # Force wrapping of generally unwrappable lines?
  'force_text_wrap'       => false,

  # replace unicode chars with what?
  'unicode_munge_str'     => '!u!',

  # warn if feed refresh is set to less than this
  'feed_refresh_warn'     => 60,

  # default refresh rate
  'feed_default_refresh'  => 120,

  # open new screen window for browser?
  'use_screen'            => true,

  # screen command
  'screen_cmd'            => 'screen -t "%s"',
  
  # browser options
  'browser'               => Path::find_browser,
  'browser_cmd'           => '${browser} %s',

  # Force raggle to accept shell metacharacters in urls.
  'force_url_meta'        => false,
  # Regular expression matching shell metacharacters to not allow in URLs
  'shell_meta_regex'       => /([\`\$]|\#{)/, # the #{ is to stop ruby
                                              # expansion.
                                              # Is that necessary?

  # lock feed names (don't update feed title from feed)
  # (you can lock individual feed titles with the --lock-title command)
  'lock_feed_title'       => false,

  # feed info on highlight
  'describe_hilited_feed' => true,
  'desc_show_site'        => false,
  'desc_show_url'         => false,
  'desc_show_divider'     => false,

  # xpaths to elements to look for item's description
  'desc_element_xpaths'   => [
    "./[local-name() = 'encoded' and namespace-uri() = 'http://purl.org/rss/1.0/modules/content/']",
    'description'
  ],

  # key bindings
  'keys'            => {
    Ncurses::KEY_RIGHT  => proc { |win, key| Key::next_window },
    ?\t                 => proc { |win, key| Key::next_window },

    Ncurses::KEY_LEFT   => proc { |win, key| Key::prev_window },
    ?\\                 => proc { |win, key| Key::prev_window },

    Ncurses::KEY_F12    => proc { |win, key| Key::quit },
    ?q                  => proc { |win, key| Key::quit },

    Ncurses::KEY_UP     => proc { |win, key| Key::scroll_up },
    Ncurses::KEY_DOWN   => proc { |win, key| Key::scroll_down },
    Ncurses::KEY_HOME   => proc { |win, key| Key::scroll_top },
    Ncurses::KEY_END    => proc { |win, key| Key::scroll_bottom },
    Ncurses::KEY_PPAGE  => proc { |win, key| Key::scroll_up_page },
    Ncurses::KEY_NPAGE  => proc { |win, key| Key::scroll_down_page },

    ?\n                 => proc { |win, key| Key::select_item },
    ?\                  => proc { |win, key| Key::select_item },

    ?u                  => proc { |win, key| Key::move_item_up },
    ?d                  => proc { |win, key| Key::move_item_down },

    Ncurses::KEY_DC     => proc { |win, key| Key::delete },
    ##
    # XXX: Meta can be dropped after spawned browser exits
    # So A, B, C or D should *not* be bound until this is fixed
    # -- richlowe 2003-06-22 (actually --pabs 2003-06-21)
    # ?D                  => proc { |win, key| Key::delete },


    # Literal control L is horrid -- richlowe 2003-06-26
    ?\                 => proc { |win, key| resize_term },
    Ncurses::KEY_RESIZE => proc { |win, key| resize_term },

    ?s                  => proc { |win, key| Key::sort_feeds },

    ?o                  => proc { |win, key| Key::open_link },

    ?m                  => proc { |win, key| mark_items_as_read },

    ?!                  => proc { |win, key| drop_to_shell },

    ?p                  => proc { |win, key| select_prev_unread },
    ?n                  => proc { |win, key| select_next_unread },
  },

  # color palette (referenced by themes)
  'color_palette'         => [
    [  1, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLACK   ],
    [  2, Ncurses::COLOR_RED,      Ncurses::COLOR_BLACK   ],
    [  3, Ncurses::COLOR_GREEN,    Ncurses::COLOR_BLACK   ],
    [  4, Ncurses::COLOR_BLUE,     Ncurses::COLOR_BLACK   ],
    [  5, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_BLACK   ],
    [  6, Ncurses::COLOR_CYAN,     Ncurses::COLOR_BLACK   ],
    [  7, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_BLACK   ],
    [ 11, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 12, Ncurses::COLOR_BLACK,    Ncurses::COLOR_RED     ],
    [ 13, Ncurses::COLOR_BLACK,    Ncurses::COLOR_GREEN   ],
    [ 14, Ncurses::COLOR_BLACK,    Ncurses::COLOR_BLUE    ],
    [ 15, Ncurses::COLOR_BLACK,    Ncurses::COLOR_MAGENTA ],
    [ 16, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 17, Ncurses::COLOR_BLACK,    Ncurses::COLOR_YELLOW  ],
    [ 21, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 22, Ncurses::COLOR_WHITE,    Ncurses::COLOR_RED     ],
    [ 23, Ncurses::COLOR_WHITE,    Ncurses::COLOR_GREEN   ],
    [ 24, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLUE    ],
    [ 25, Ncurses::COLOR_WHITE,    Ncurses::COLOR_MAGENTA ],
    [ 26, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 27, Ncurses::COLOR_WHITE,    Ncurses::COLOR_YELLOW  ],
    [ 31, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 32, Ncurses::COLOR_RED,      Ncurses::COLOR_CYAN    ],
    [ 33, Ncurses::COLOR_GREEN,    Ncurses::COLOR_CYAN    ],
    [ 34, Ncurses::COLOR_BLUE,     Ncurses::COLOR_CYAN    ],
    [ 35, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_CYAN    ],
    [ 36, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 37, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_CYAN    ],
  ],

  'attr_palette'          => {
    'normal'        => Ncurses::A_NORMAL,
    'normal'        => Ncurses::A_NORMAL,
    'standout'      => Ncurses::A_STANDOUT,
    'underline'     => Ncurses::A_UNDERLINE,
    'reverse'       => Ncurses::A_REVERSE,
    'blink'         => Ncurses::A_BLINK,
    'dim'           => Ncurses::A_DIM,
    'bold'          => Ncurses::A_BOLD,
    'protect'       => Ncurses::A_PROTECT,
    'invis'         => Ncurses::A_INVIS,
    'altcharset'    => Ncurses::A_ALTCHARSET,
    'chartext'      => Ncurses::A_CHARTEXT,
  },

  # default theme settings
  'theme'           => {
    # theme information
    'name'          => 'Default Theme',
    'author'        => 'Paul Duncan <pabs@pablotron.org>',
    'url'           => 'http://www.raggle.org/',

    # window order (order for window changes, etc)
    'window_order'  => ['feed', 'item', 'desc'],
    
    # status bar color
    'status_bar_cols'       => 24,

    # feed window attributes
    'win_feed'      => {
      'key'         => 'feed',
      'title'       => 'Feeds',
      'coords'      => [0, 0, 25, -1],
      'type'        => 'list',
      'colors'      => { 
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        # 'a_title'   => 36,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
        'empty'     => 2,
        'h_empty'     => 32,
      },
    },

    # item window attributes
    'win_item'      => {
      'key'         => 'item',
      'title'       => 'Items',
      'coords'      => [25, 0, -1, 15],
      'type'        => 'list',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
      },
    },

    # desc window attributes
    'win_desc'      => {
      'key'         => 'desc',
      'title'       => 'Description',
      'coords'      => [25, 15, -1, -1],
      'type'        => 'text',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'url'       => 6,
        'date'      => 6,

        'f_title'   => [1, 'bold'],
        'f_update'  => 1,
        'f_url'     => 1,
        'f_site'    => 1,
        'f_error'   => 2,
        'f_desc'    => 1,
      },
    },
  },

  # live feeds
  'feeds'    => FeedList.new,

  # debugging / internal options (don't touch)
  'use_raw_mode'  => true,
  'use_noecho'    => true,

  'default_feeds' => [
    { 'title'     => '  Raggle Help', # add a space so sorting puts it at top
      'url'       => "http://www.raggle.org/files/help/help-#{$VERSION}.xml",
      'site'      => 'http://www.raggle.org/',
      'refresh'   => 240,
      'updated'   => -1,
      'desc'      => '',
      'items'     => [ ],
    },
    { 'title'     => 'Alternet',
      'url'       => 'http://www.alternet.org/rss/rss.xml',
      'site'      => 'http://www.alternet.org/',
      'desc'      => 'Alternative News and Information.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Daily Daemon News',
      'url'       => 'http://daily.daemonnews.org/ddn.rdf.php3',
      'site'      => 'http://daemonnews.org/',
      'desc'      => 'Daily Daemon News',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'FreshMeat',
      'url'       => 'http://themes.freshmeat.net/backend/fm-newsletter.rdf',
      'site'      => 'http://www.freshmeat.net/',
      'desc'      => 'FreshMeat.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'KernelTrap',
      'url'       => 'http://kerneltrap.org/module.php?mod=node&op=feed',
      'site'      => 'http://www.kerneltrap.org/',
      'desc'      => 'KernelTrap',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Kuro5hin',
      'url'       => 'http://www.kuro5hin.org/backend.rdf',
      'site'      => 'http://www.kuro5hin.org/',
      'desc'      => 'Kuro5hin',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Linux Weekly News',
      'url'       => 'http://www.lwn.net/headlines/rss',
      'site'      => 'http://www.lwn.net/',
      'desc'      => 'Linux Weekly News',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Pablotron',
      'url'       => 'http://www.pablotron.org/?theme=rss&amp;max=15',
      'site'      => 'http://www.pablotron.org/',
      'desc'      => 'Paul Duncan\'s personal site.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Pigdog Journal',
      'url'       => 'http://www.pigdog.org/pigdog.rdf',
      'site'      => 'http://www.pigdog.org/',
      'desc'      => 'Pigdog Journal',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Slashdot',
      'url'       => 'http://slashdot.org/slashdot.rss',
      'site'      => 'http://www.slashdot.org/',
      'desc'      => 'Slashdot',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'This Modern World',
      'url'       => 'http://www.thismodernworld.com/index.rdf',
      'site'      => 'http://www.thismodernworld.com/',
      'desc'      => 'This Modern World',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'W3C',
      'url'       => 'http://www.w3.org/2000/08/w3c-synd/home.rss',
      'site'      => 'http://www.w3.org/',
      'desc'      => 'W3C',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
  ],
}

if __FILE__ == $0
  if $config['diag']
    begin
      main
    rescue => err
      puts "#{err.message} (#{err.class})"
      #err.backtrace.collect! { |name| name = "[#{name}]" }
      #puts err.backtrace.reverse.join(" -> ")
      err.backtrace.each { |frame| puts frame }
    end
  else
    main
  end
end
