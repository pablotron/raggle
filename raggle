#!/usr/bin/env ruby

# Raggle version
$VERSION = '0.1.0'

# change to 'feeds' for live feeds
$SRC = 'feeds'
# $SRC = 'debug_feeds'

# load required modules
require 'ncurses'
require 'yaml'
require 'rexml/document'
require 'net/http'
begin 
  require 'net/https'
  $HAVE_SSL = true
rescue
  $HAVE_SSL = false
end

# default config
$config = {
  'config_dir'            => ENV['HOME'] << '/.raggle',
  'config_path'           => '${config_dir}/config.rb',
  'feed_cache_path'       => '${config_dir}/feed_cache.yaml',
  'grab_log_path'         => '${config_dir}/grab.log',

  # feed cache handling
  'load_feed_cache'       => true,
  'save_feed_cache'       => true,

  # ui options
  'focus'                 => 'select', # ['none', 'select', 'auto']
  'no_desc_auto_focus'    => true,

  # date formats
  'item_date_format'      => '%c',
  'desc_date_format'      => '%c',

  # messages
  'msg_welcome'           => " Welcome to Raggle #{$VERSION}.",
  'msg_exit'              => "| Press ESC or Q to exit ",
  'msg_close'             => '[X] ',

  # menu bar color
  'menu_bar_cols'         => 24,

  # status bar color
  'status_bar_cols'       => 24,

  # input select timeout (in seconds)
  'input_select_timeout'  => 5.0,

  # feed sleep interval (in seconds)
  'feed_sleep_interval'   => 60,

  # strip html from item contents?
  'strip_html'            => true,

  # color palette (referenced by window attributes)
  'color_palette'         => [
    [  1, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLACK   ],
    [  2, Ncurses::COLOR_RED,      Ncurses::COLOR_BLACK   ],
    [  3, Ncurses::COLOR_GREEN,    Ncurses::COLOR_BLACK   ],
    [  4, Ncurses::COLOR_BLUE,     Ncurses::COLOR_BLACK   ],
    [  5, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_BLACK   ],
    [  6, Ncurses::COLOR_CYAN,     Ncurses::COLOR_BLACK   ],
    [  7, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_BLACK   ],
    [ 11, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 12, Ncurses::COLOR_BLACK,    Ncurses::COLOR_RED     ],
    [ 13, Ncurses::COLOR_BLACK,    Ncurses::COLOR_GREEN   ],
    [ 14, Ncurses::COLOR_BLACK,    Ncurses::COLOR_BLUE    ],
    [ 15, Ncurses::COLOR_BLACK,    Ncurses::COLOR_MAGENTA ],
    [ 16, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 17, Ncurses::COLOR_BLACK,    Ncurses::COLOR_YELLOW  ],
    [ 21, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 22, Ncurses::COLOR_WHITE,    Ncurses::COLOR_RED     ],
    [ 23, Ncurses::COLOR_WHITE,    Ncurses::COLOR_GREEN   ],
    [ 24, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLUE    ],
    [ 25, Ncurses::COLOR_WHITE,    Ncurses::COLOR_MAGENTA ],
    [ 26, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 27, Ncurses::COLOR_WHITE,    Ncurses::COLOR_YELLOW  ],
  ],

  # feed window attributes
  'win_feed'      => {
    'key'         => 'feed',
    'title'       => 'Feeds',
    'coords'      => [0, 0, 20, -1],
    'type'        => 'list',
    'colors'      => { 
      'title'     => 1,
      'text'      => 1,
      'h_text'    => 16,
      'box'       => 2,
      'a_title'   => 21,
      'a_box'     => 2,
    },
  },

  # item window attributes
  'win_item'      => {
    'key'         => 'item',
    'title'       => 'Items',
    'coords'      => [20, 0, -1, 20],
    'type'        => 'list',
    'colors'      => {
      'title'     => 1,
      'text'      => 1,
      'h_text'    => 16,
      'box'       => 4,
      'a_title'   => 21,
      'a_box'     => 4,
    },
  },

  # desc window attributes
  'win_desc'      => {
    'key'         => 'desc',
    'title'       => 'Description',
    'coords'      => [20, 20, -1, -1],
    'type'        => 'text',
    'colors'      => {
      'title'     => 1,
      'text'      => 1,
      'h_text'    => 16,
      'box'       => 6,
      'a_title'   => 21,
      'a_box'     => 6,
      'url'       => 6,
      'date'      => 6,
    },
  },

  # live feeds
  'feeds'         => [
    { 'title'     => 'Raggle',
      'url'       => 'http://www.pablotron.org/software/raggle/help.rss',
      'site'      => 'http://www.pablotron.org/software/raggle/',
      'refresh'   => -1,
      'updated'   => 1055113783,
      'items'     => [
        { 'title' => 'Introduction',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Welcome to Raggle!
. .
Raggle is a command-line RSS aggregator, written in Ruby
(http://www.ruby-lang.org/).  Raggle is free software; please see the
file COPYING or the License item in this feed for licensing and
warranty information.', },
        { 'title' => 'License',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Copyright (C) 2003
Paul Duncan, and various contributors.
. . 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
. .
The above copyright notice and this permission notice shall be included in
all copies of the Software, its documentation and marketing & publicity 
materials, and acknowledgment shall be given in the documentation, materials
and software packages that this Software was used.
. .   
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          ', },
        { 'title' => 'Usage',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Keyboard .
======== .
- Tab, <-, -> : Window navigation .
- Up, Down : Item navigation   .
- Enter, Space : Select active item .
- Q, ESC, F12 : Exit Raggle .
.
Adding Feeds .
============ .
TODO (right now you have to edit the feed cache manually) .
.
', },
        { 'title' => 'Configuring Raggle',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Configuring Raggle .
================== .
TODO
', },
        { 'title' => 'Reporting Bugs',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Reporting Bugs .
============== .
Please make sure you\'re using the latest version of Raggle before
reporting bugs.  That said, you can submit bug reports to
ragglebug@pablotron.org.
', },
      ],
    },
    { 'title'     => 'Alternet',
      'url'       => 'http://www.alternet.org/rss/rss.xml',
      'site'      => 'http://www.alternet.org/',
      'desc'      => 'Alternative News and Information.',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Open Sounds',
      'url'       => 'http://www.opensounds.net/backend.php',
      'site'      => 'http://www.opensounds.net/',
      'desc'      => 'John Maguire.',
      'refresh'   => 60,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
  ],

  # debugging options (don't touch)
  'use_raw_mode'  => true,
  'use_noecho'    => true,

  'debug_feeds'   => [
    { 'title'     => 'Raggle',
      'url'       => 'http://www.pablotron.org/software/raggle/help.rss',
      'refresh'   => -1,
      'items'     => [
        { 'title' => 'Introduction',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'desc'  => 'Welcome to Raggle!
. .
Raggle is a command-line RSS aggregator, written in Ruby
(http://www.ruby-lang.org/).  Raggle is free software; please see the
file COPYING or the License item in this feed for licensing and
warranty information.', },
        { 'title' => 'License',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'desc'  => 'Copyright (C) 2003
Paul Duncan, and various contributors.
. . 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
. .
The above copyright notice and this permission notice shall be included in
all copies of the Software, its documentation and marketing & publicity 
materials, and acknowledgment shall be given in the documentation, materials
and software packages that this Software was used.
. .   
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          ', },
        { 'title' => 'Usage',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'desc'  => 'more fun with testing', },
      ],
    },
    { 'title'     => 'Slashdot',
      'url'       => 'http://slashdot.org/slashdot.rss',
      'refresh'   => 30,
      'items'     => [
        { 'title' => 'test item 1',
          'url'   => 'http://www.pablotron.org/test?item=1',
          'date'  => 89743298,
          'desc'  => 'this is a test item', },
        { 'title' => 'test item 2',
          'url'   => 'http://www.pablotron.org/test?item=2',
          'date'  => 3243298,
          'desc'  => 'this is another test item', },
        { 'title' => 'test item 3',
          'url'   => 'http://www.pablotron.org/test?item=3',
          'date'  => 112239847,
          'desc'  => 'more fun with testing', },
      ],
    },
    { 'title'     => 'Alternet',
      'url'       => 'http://www.alternet.org/alternet.rss',
      'refresh'   => 30,
      'items'     => [
        { 'title' => 'asdfkjsaldkjfs1',
          'url'   => 'http://www.pablotron.org/test?item=1',
          'date'  => 32743298,
          'desc'  => 'asdfklasjdfldsa', },
        { 'title' => 'blarhg blargh blarh2',
          'url'   => 'http://www.pablotron.org/test?item=1',
          'date'  => 32897498,
          'desc'  => 'asdfklasjdfldsa', },
        { 'title' => 'cripes 3',
          'url'   => 'http://www.pablotron.org/test?item=1',
          'date'  => 32893298,
          'desc'  => 'asdfklasjdfldsa', },
        { 'title' => 'diddly doo 4',
          'url'   => 'http://www.pablotron.org/test?item=1',
          'date'  => 32893298,
          'desc'  => 'this is a test item', },
        { 'title' => 'Text Reflow Sample',
          'url'   => 'http://www.pablotron.org/test?item=2',
          'date'  => 3243298,
          'desc'  => 'Some sample text:
.
The Saturn Game, by Poul Anderson
.
One of the writing problems peculiar to science fiction is that science has a
wa y of catching up with your imagining. Just as you finish writing a book
about th e poor folks who live on the perpetually dark side of Mercury, the
damned Marine r flyby shows that there\'s no such thing as a dark side. Out the
window with the manuscript (maybe followed by the typewriter and even the
writer).
', },
        { 'title' => 'bleh de bleh bleh6',
          'url'   => 'http://www.pablotron.org/test?item=3',
          'date'  => 112239847,
          'desc'  => 'more fun with testing', },
      ],
    },
  ],
}

module Feed
  # Feed::Item struct definition
  Item = Struct.new :title, :link, :desc, :date

  #
  # Return the contents of a URL
  #
  def Feed::get_url(url)
    port = 80
    use_ssl = false

    if url =~ /^https:/
      raise 'HTTPS support requires OpenSSL-Ruby' unless $HAVE_SSL
      use_ssl = true
    end

    # strip 'http://' prefix from URL
    url.gsub!(/^\w+?:\/\//, '') if url =~ /^\w+?:\/\//

    # get host and path portions of url
    raise "Couldn't parse URL: \"#{url}\"" unless url =~ /^(.+?)\/(.+)$/
    host, path = $1, $2

    # check for port in url
    if host =~ /:(\d+)$/
      port = $1 
      host.gsub!(/:(\d+)$/, '')
    end

    # init http connection
    http = Net::HTTP.start(host, port)
    http.use_ssl = use_ssl if $HAVE_SSL
    raise "Couldn't connect to host \"#{host}:#{port}\"" unless http

    # get result
    ret = ''
    begin
      http.get('/' << path) { |line| ret << line }
    rescue 
      raise "HTTP Error: #$!"
    end

    # close HTTP connection
    # Note: if we don't specify this, then the connection is pooled for the
    # HTTP/1.1 spec (do we prefer that kind of behavior?  maybe I should make in
    # an option)
    http.finish

    # return URL content
    ret
  end

  class Channel
    attr_accessor :title, :link, :desc, :lang, :items

    def initialize(url)
      parse_rss_url url
    end
      
    # 
    # Parse an RSS URL and return a FeedChannel object (which contains,
    # among other things, an array of feed_item structs)
    #
    def parse_rss_url(url)
      begin
        content = Feed::get_url url
      rescue
        raise "Couldn't get URL \"#{url}\": #$!."
      end

      # parse URL content
      doc = REXML::Document.new content

      # get channel info
      e = nil
      @title = e.text if e = doc.root.elements['//channel/title']
      @link = e.text if e = doc.root.elements['//channel/link']
      @desc = e.text if e = doc.root.elements['//channel/description']
      @lang = e.text if e = doc.root.elements['//channel/language']
  
      # build list of feed items
      @items = []
      doc.root.elements.each('//item') { |e| 
        # get item attributes (the ones that are set, anyway... stupid
        # RSS)
        h = {}
        [ 'title', 'link', 'description', 'date' ].each { |val|
          h[val] = (t_e = e.elements[val]) ? t_e.text : ''
        }

        # insert new item
        @items << Feed::Item.new(h['title'], h['link'],
                                 h['description'], h['date'])
      }
    end
  end
end


class Window
  attr_accessor :win, :win_type, :title, :key, :colors, :active, :items, :active_item

  #
  # window constructor
  #
  def initialize(opts)
    coords = opts['coords']
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    @active_item = 0
    @items = []

    @title = opts['title']
    @win_type = opts['type']
    @key = opts['key']
    @colors = opts['colors'].dup

    @win = Ncurses::newwin coords[3], coords[2], coords[1], coords[0]
    refresh
  end

  #
  # refresh window title and border (but not the contents)
  # 
  def refresh(refresh_contents = false)
    win.color_set @colors[@active ? 'a_box' : 'box'], nil
    Ncurses::box win, 0, 0
    win.color_set @colors[@active ? 'a_title' : 'title'], nil
    Ncurses::mvwprintw win, 0, 1, " #{@title} "
    win.color_set @colors['text'], nil
    Ncurses::wrefresh win
  end

  def clear
    @win.color_set @colors['text'], nil
    @win.clear
  end

  #
  # draw text in window
  #
  def draw(orig_text, x = 1, y = 1, hilited = false, refresh_win = true)
    ha = []; wa = []
    Ncurses::getmaxyx win, ha, wa
    w, h = wa[0], ha[0]

    # reflow text if it's a text window
    # DOES THIS BELOGN HERE?
    if @win_type == 'text'
      text = ''
      curr_line = ''
      orig_text.split(/\s+/).each { |word|
        if word == '.'
          text << curr_line << "\n" 
          curr_line = ''
        elsif curr_line.length + word.length > w - 2
          text << curr_line << "\n"
          curr_line = "#{word} "
        else
          curr_line += "#{word} "
        end
      }
      text << curr_line << "\n"
    else
      text = orig_text
    end

    # draw text in window
    @win.color_set @colors['h_text'], nil if hilited
    text.each_line { |line|
      Ncurses::mvwprintw @win, y, x, line.slice(0, w - x - 1)
      y += 1
    }
    @win.color_set @colors['text'], nil

    refresh if refresh_win
  end

  #
  # handle keyboard input
  #
  def handle_key(key)
    case key
    when Ncurses::KEY_UP
      if @items.size > 0
        ai = @active_item
        @active_item = ((ai - 1 < 0) ? @items.size : ai) - 1
        draw_items
        select_win_item if $config['focus'] == 'auto'
      end
    when Ncurses::KEY_DOWN
      if @items.size > 0
        @active_item = (@active_item + 1) % @items.size
        draw_items
        select_win_item if $config['focus'] == 'auto'
      end
    when ?\n
      select_win_item
    when ?\ 
      select_win_item
    end
  end

  #
  # select currently hilited window item
  #
  def select_win_item
    if @items && @items.size > 0
      if @items[@active_item].has_key? 'feed'
        select_feed @items[@active_item]['feed']
      elsif @items[@active_item].has_key? 'item'
        select_item @items[@active_item]['item']
      elsif @items[@active_item].has_key? 'url'
        # exec ['Eterm', '-e', 'links', 
        #       @items[@active_item]['url']] if fork == 0
      end
    end
  end

  #
  # redraw window items
  #
  def draw_items
    y = 0
    if @win_type == 'text'
      @items.each { |item|
        y += 1
        draw("Link: ", 1, y, false)
        @win.color_set @colors['url'], nil
        draw(item['url'], 7, y, false)

        # don't draw the date if it isn't set (silly RSS)
        if item['date'] && item['date'] != ''
          y += 1
          draw("Date: ", 1, y, false)

          # handle date string shenanigans
          if ((i_val = item['date'].to_i) > 0)
            d_str = Time.at(i_val).strftime($config['desc_date_format'])
          else
            d_str = item['date']
          end

          # draw date string
          @win.color_set @colors['date'], nil
          draw(d_str, 7, y, false)
        end
        str = item['title']
        str = item['title'].gsub(/<[^>]+?>/, '') if $config['strip_html']
        draw(str, 1, y += 2, false)
      }
    else
      @items.each { |i| draw(i['title'], 1, y += 1, y - 1 == @active_item) }
    end
    refresh(true)
  end
end

#
# set status bar message
#
def set_status(str)
  str += ' ' * ($config['w'] / 2 - str.length)
  e_msg = $config['msg_exit']
  e_msg = ' ' * ($config['w'] / 2 - e_msg.length) + e_msg
  msg = str << e_msg

  Ncurses::wcolor_set Ncurses::stdscr, $config['status_bar_cols'], nil
  Ncurses::mvprintw $config['h'], 0, msg
  Ncurses::refresh
end

# 
# set active window 
#
def set_active_win(a_win)
  $wins[$a_win].active = false
  $wins[$a_win].refresh
  $a_win = a_win
  $wins[$a_win].active = true
  $wins[$a_win].refresh
end

#
# get window id by key
#
def get_win_id(str)
  $wins.each_index { |i| return i if $wins[i].key == str }
  -1
end


# 
# expand path macros in $config
#
def expand_config
  $config.each { |key, val| 
    next unless val.class == String && val =~ /\${(.+?)}/
    orig_val = val.dup
    val.gsub!(/\${(.+?)}/, $config[$1])
    # puts "\"#{orig_val}\" expands to \"#{val}\""
  }
end

#
# set active feed by id
#
def select_feed(id)
  $a_feed = id
  $a_item = 0

  # clear item window
  item_id = get_win_id 'item'
  $wins[item_id].active_item = 0
  $wins[item_id].items.clear

  # unused.. remove it?
  fmt = $config['item_date_format']

  # wtf is happening here?
  raise "id.class.to_s = #{id.class.to_s}" unless id.class == Fixnum
  
  # iterate through feed items
  $config[$SRC][id]['items'].each_with_index { |item, i|
    # can't depend on the date being in a consistent format, or
    # being defined at all, for that matter :( :( :(
    # title = item['title'] + ' (' +
    #         Time.at(item['date'].to_i).strftime(fmt) << ')'

    # build title string
    if item['date'] && item['date'].size > 0
      d_str = item['date']
      d_str = Time.at(item['date'].to_i).strftime(fmt) if item['date'].to_i > 0
      title = "#{item['title']} (#{d_str})"
    else 
      title = item['title'].dup
    end

    $wins[item_id].items << {
      'title' => title,
      'item'  => i,
    }
  }

  # redraw item window
  $wins[item_id].win.clear
  $wins[item_id].draw_items

  # activate item window
  set_active_win(item_id) if $config['focus'] == 'select'
end

#
# set active item by id
#
def select_item(id)
  $a_item = id

  # clear description window
  desc_id = get_win_id 'desc'
  $wins[desc_id].active_item = 0
  $wins[desc_id].items.clear

  # mark item as read
  $config[$SRC][$a_feed]['items'][id]['read?'] = true

  # load item
  $wins[desc_id].items << {
    'title' => $config[$SRC][$a_feed]['items'][id]['desc'],
    'url'   => $config[$SRC][$a_feed]['items'][id]['url'],
    'date'  => $config[$SRC][$a_feed]['items'][id]['date'],
  }

  # redraw description window
  $wins[desc_id].win.clear
  $wins[desc_id].draw_items

  # activate description window
  set_active_win(desc_id) if $config['focus'] == 'select' and
                             !$config['no_desc_auto_focus']
end

#
# save feed cache 
#
def save_feed_cache
  File.open($config['feed_cache_path'], 'w') { |f|
    f.puts $config[$SRC].to_yaml
  }
end

#######################################################################
# End Shenanigans, Begin Actual Code                                  #
#######################################################################

# expand the default config hash
expand_config

# parse command-line options
# TODO

# if $HOME/.raggle doesn't exist, then create it
Dir::mkdir $config['config_dir'] unless test ?d , $config['config_dir']

# load user config ($HOME/.raggle/config.rb)
load $config['config_path'], false if test ?e, $config['config_path']
expand_config

# load feed cache
if $config['load_feed_cache'] && test(?e, $config['feed_cache_path'])
  $config[$SRC] = YAML::load(File::open($config['feed_cache_path']))
end

# start feed grabbing thread
feed_thread = Thread.new {
  File.open($config['grab_log_path'], 'a') { |log|
    log.puts "#{Time.now}: Starting grab log."
    loop {
      $config[$SRC].each { |feed|
        t = Time.now

        log.puts "#{Time.now}: Checking feed \"#{feed['title']}\""
        next unless feed['refresh'] > 0 && 
                    feed['updated'] + (feed['refresh'] * 60) < t.to_i

        # update statusbar and grab log
        log.puts "#{t}: Updating feed \"#{feed['title']}\" from \"#{feed['url']}\""
        # set_status "Updating \"#{feed['title']}\"..."

        # TODO: save old items
        # old_items = feed['items']
        
        # get channel
        begin
          chan = Feed::Channel.new(feed['url'])
        rescue
          # set_status "Error updating \"#{feed['title']}\"."
          log.puts "#{t}: Error: #$!"
          next
        end

        # update feed attributes
        feed['title'] = chan.title
        feed['site'] = chan.link
        feed['updated'] = t.to_i

        # clear feed list
        feed['items'].clear

        # insert new items
        chan.items.each { |item|
          feed['items'] << {
            'title' => item.title,
            'date'  => item.date,
            'url'   => item.link,
            'desc'  => item.desc,
            'read?' => false,
          }
        }

        # redraw feed / item windows
        $update_windows = true
      }

      # finish log entries
      interval = $config['feed_sleep_interval']
      log.puts "#{Time.now}: Done checking.  Sleeping for #{interval}s."
      log.flush
      sleep interval
    }
  }
}

begin
  # initialize screen & keyboard
  Ncurses::initscr
  Ncurses::raw if $config['use_raw_mode']
  Ncurses::keypad Ncurses::stdscr, 1
  Ncurses::noecho if $config['use_noecho']
  Ncurses::start_color

  # exit -1 unless Ncurses::has_colors?

  # initialize color pairs
  $config['color_palette'].each { |ary| Ncurses::init_pair *ary }

  # get screen coordinates
  h = []; w = []
  Ncurses::getmaxyx Ncurses::stdscr, h, w
  $config['w'] = w[0]
  $config['h'] = h[0] - 1

  # draw menu bar
  # c_msg = $config['msg_close']
  # msg = (' ' * ($config['w'] - c_msg.length)) << c_msg
  # Ncurses::wcolor_set Ncurses::stdscr, $config['menu_bar_cols'], nil
  # Ncurses::mvprintw 0, 0, msg
  # Ncurses::refresh

  # draw status bar
  set_status $config['msg_welcome']
  
  # create windows
  $a_win = 0
  $wins = []
  ['feed', 'item', 'desc'].each { |i|
    $wins << Window.new($config["win_#{i}"])
    # $wins[-1].draw LONG_STRING
  }
  set_active_win(0)
  
  $a_feed, $a_item = 0, 0
  
  # populate feed window
  id = get_win_id 'feed'
  $config[$SRC].each_with_index { |feed, i|
    # count unread items
    unread_count = 0
    feed['items'].each { |item| unread_count += 1 unless item['read?'] }

    # build title
    title = feed['title'] + " (#{unread_count}/#{feed['items'].size})"
    $wins[id].items << {
      'title' => title,
      'feed'  => i,
    }
  }
  $wins[id].draw_items
  
  select_feed(0)
  set_active_win(0)
  
  # main input loop
  timeout = $config['input_select_timeout']
  done = false
  until done
    # handle keyboard input
    r = select [$stdin], nil, nil, timeout
    if r && r.size > 0
      case c = Ncurses::getch
      when Ncurses::KEY_RIGHT
        set_active_win(($a_win + 1) % $wins.size)
      when ?\t
        set_active_win(($a_win + 1) % $wins.size)
      when Ncurses::KEY_LEFT
        set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
      when ?\\
        set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
      when Ncurses::KEY_F12
        done = true
      when ?q
        done = true
      when ?\e
        done = true
      when ?
        resize_wins
      else  
        $wins[$a_win].handle_key c
      end
    end

    # refresh window contents if there's been a feed update
    if $update_wins
      $update_wins = false
      wins.each { |win| win.draw_items }
    end
  end
ensure
  # clean up screen on exit
  Ncurses::endwin

  # stop feed grabbing thread
  feed_thread.exit

  # save feed cache
  save_feed_cache if $config['save_feed_cache']
end
