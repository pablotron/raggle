#!/usr/bin/env ruby

# Raggle version
$VERSION = '0.1.0'

# change to 'feeds' for live feeds
$SRC = 'feeds'
# $SRC = 'debug_feeds'

# load required modules
require 'pstore'
require 'ncurses'
require 'yaml'
require 'rexml/document'
require 'net/http'

begin 
  require 'net/https'
  $HAVE_SSL = true
rescue
  $HAVE_SSL = false
end

###################
# utility methods #
###################

#
# I like die
#
def die(str)
  $stderr.puts 'FATAL: ' << str
  exit -1
end

#
# find an application in your $PATH
#
def find_app(app)
  ENV['PATH'].split(/:/).find { |path| test ?x, "#{path}/#{app}" }
end

#
# Find browser
#
def find_browser
  ret = ENV['RAGGLE_BROWSER']
  ret = ENV['BROWSER']
  ret = 'links' if !ret && test(?e, find_app('links'))
  ret = 'w3m' if !ret && test(?e, find_app('w3m'))
  ret = 'lynx' if !ret && test(?e, find_app('lynx'))

  # die if we couldn't find a browser
  die "Couldn't find suitable browser.  Is $BROWSER set?" unless ret

  # return browser
  ret
end

# 
# Are we running in a screen session?
#
def in_screen?
  ENV['WINDOW'] != nil
end

##################
# default config #
##################
$config = {
  'config_dir'            => ENV['HOME'] << '/.raggle',
  'config_path'           => '${config_dir}/config.rb',
  'feed_list_path'        => '${config_dir}/feeds.yaml',
  'feed_cache_path'       => '${config_dir}/feed_cache.store',
  'theme_path'            => '${config_dir}/theme.yaml',
  'grab_log_path'         => '${config_dir}/grab.log',
  'cache_lock_path'       => '${config_dir}/lock',

  # feed list handling
  'load_feed_list'        => true,
  'save_feed_list'        => true,

  # feed cache handling
  'load_feed_cache'       => true,
  'save_feed_cache'       => true,

  # theme handling
  'load_theme'            => true,
  'save_theme'            => true,

  # feed list, feed cache, and theme lock handling
  'use_cache_lock'        => true,

  # ui options
  'focus'                 => 'select', # ['none', 'select', 'auto']
  'no_desc_auto_focus'    => true,
  'scroll_wrapping'       => true,

  # Number of list items per "page" (wrt page up/down)
  'page_step'             => 4,

  # date formats
  'item_date_format'      => '%c',
  'desc_date_format'      => '%c',

  # messages
  'msg_welcome'           => " Welcome to Raggle #{$VERSION}.",
  'msg_exit'              => "| Press Q to exit ",
  'msg_close'             => '[X] ',
  'msg_load_config'       => 'Raggle: Loading config...',
  'msg_load_list'         => 'Raggle: Loading feed list...',
  'msg_save_list'         => 'Raggle: Saving feed list...',
  'msg_load_cache'        => 'Raggle: Loading feed cache...',
  'msg_save_cache'        => 'Raggle: Saving feed cache...',
  'msg_load_theme'        => 'Raggle: Loading theme...',
  'msg_save_theme'        => 'Raggle: Saving theme...',
  'msg_thanks'            => 'Thanks for using Raggle!',

  # menu bar color
  'menu_bar_cols'         => 24,

  # input select timeout (in seconds)
  'input_select_timeout'  => 0.2,

  # feed sleep interval (in seconds)
  'feed_sleep_interval'   => 60,

  # grab log mode (a == append, w == write)
  'grab_log_mode'         => 'w',

  # strip html from item contents?
  'strip_html_tags'       => true,

  # decode html escape sequences?
  'unescape_html'         => true,

  # replace unicode chars with what?
  'unicode_munge_str'     => 'ZZ',

  # open new screen window for browser?
  'use_screen'            => true,

  # screen command
  'screen_cmd'            => 'screen -t "%s"',
  
  # browser options
  'browser'               => find_browser,
  'browser_cmd'           => '${browser} %s',

  # color palette (referenced by themes)
  'color_palette'         => [
    [  1, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLACK   ],
    [  2, Ncurses::COLOR_RED,      Ncurses::COLOR_BLACK   ],
    [  3, Ncurses::COLOR_GREEN,    Ncurses::COLOR_BLACK   ],
    [  4, Ncurses::COLOR_BLUE,     Ncurses::COLOR_BLACK   ],
    [  5, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_BLACK   ],
    [  6, Ncurses::COLOR_CYAN,     Ncurses::COLOR_BLACK   ],
    [  7, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_BLACK   ],
    [ 11, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 12, Ncurses::COLOR_BLACK,    Ncurses::COLOR_RED     ],
    [ 13, Ncurses::COLOR_BLACK,    Ncurses::COLOR_GREEN   ],
    [ 14, Ncurses::COLOR_BLACK,    Ncurses::COLOR_BLUE    ],
    [ 15, Ncurses::COLOR_BLACK,    Ncurses::COLOR_MAGENTA ],
    [ 16, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 17, Ncurses::COLOR_BLACK,    Ncurses::COLOR_YELLOW  ],
    [ 21, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 22, Ncurses::COLOR_WHITE,    Ncurses::COLOR_RED     ],
    [ 23, Ncurses::COLOR_WHITE,    Ncurses::COLOR_GREEN   ],
    [ 24, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLUE    ],
    [ 25, Ncurses::COLOR_WHITE,    Ncurses::COLOR_MAGENTA ],
    [ 26, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 27, Ncurses::COLOR_WHITE,    Ncurses::COLOR_YELLOW  ],
    [ 31, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 32, Ncurses::COLOR_RED,      Ncurses::COLOR_CYAN    ],
    [ 33, Ncurses::COLOR_GREEN,    Ncurses::COLOR_CYAN    ],
    [ 34, Ncurses::COLOR_BLUE,     Ncurses::COLOR_CYAN    ],
    [ 35, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_CYAN    ],
    [ 36, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 37, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_CYAN    ],
  ],

  # default theme settings
  'theme'           => {
    # theme information
    'name'          => 'Default Theme',
    'author'        => 'Paul Duncan <pabs@pablotron.org>',
    'url'           => 'http://www.pablotron.org/software/raggle/',

    # status bar color
    'status_bar_cols'       => 24,

    # feed window attributes
    'win_feed'      => {
      'key'         => 'feed',
      'title'       => 'Feeds',
      'coords'      => [0, 0, 25, -1],
      'type'        => 'list',
      'colors'      => { 
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        # 'a_title'   => 36,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
      },
    },

    # item window attributes
    'win_item'      => {
      'key'         => 'item',
      'title'       => 'Items',
      'coords'      => [25, 0, -1, 15],
      'type'        => 'list',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
      },
    },

    # desc window attributes
    'win_desc'      => {
      'key'         => 'desc',
      'title'       => 'Description',
      'coords'      => [25, 15, -1, -1],
      'type'        => 'text',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'url'       => 6,
        'date'      => 6,
      },
    },
  },

  # live feeds
  'feeds'         => [
    { 'title'     => 'Raggle',
      'url'       => 'http://www.pablotron.org/software/raggle/help.rss',
      'site'      => 'http://www.pablotron.org/software/raggle/',
      'refresh'   => -1,
      'updated'   => 1055113783,
      'items'     => [
        { 'title' => 'Introduction',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Welcome to Raggle!
. .
Raggle is a command-line RSS aggregator, written in Ruby
(http://www.ruby-lang.org/).  Raggle is free software; please see the
file COPYING or the License item in this feed for licensing and
warranty information.', },
        { 'title' => 'License',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Copyright (C) 2003
Paul Duncan, and various contributors.
. . 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
. .
The above copyright notice and this permission notice shall be included in
all copies of the Software, its documentation and marketing & publicity 
materials, and acknowledgment shall be given in the documentation, materials
and software packages that this Software was used.
. .   
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          ', },
        { 'title' => 'Usage',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Keyboard .
========                            .
- Tab, <-, -> : Window navigation   .
- Up, Down : Item navigation        .
- Home, End : Start, end of list.   .
- Enter, Space : Select active item .
- Q, F12 : Exit Raggle              .
.
', },
        { 'title' => 'Keyboard',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Keyboard .
========                            .
- Tab, <-, -> : Window navigation   .
- Up, Down : Item navigation        .
- Home, End : Start, end of list.   .
- Enter, Space : Select active item .
- Q, F12 : Exit Raggle              .
.
', },
        { 'title' => 'Reading Feeds',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Reading Feeds .
============= .
To read a given feed, hilite it in the Feed window and press Enter or
Space.  The list of items available from that feed will be displayed in
the Item window.  Unread feed items are marked slightly differently than
read feed items (the color is adjustable on a per-theme basis).  To view
the full story linked from a feed item, navigate to the Description
window (using Tab or the Left and Right arrow keys) and press Space or
Enter.  If Raggle is running in a screen session, it will invoke your
browser of choice in a separate screen window (this behavior is
configurable; see the \'use_screen\' option in the "Configuring Raggle"
section for additional information).  There are several different window
navigation modes available, see the \'focus\' "Configuring Raggle"
section for additional information.
', },
        { 'title' => 'Adding Feeds',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Adding Feeds .
============ .
TODO (right now you have to edit the feed cache manually) .
.
', },
        { 'title' => 'Configuring Raggle',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Configuring Raggle .
================== .
TODO
', },
        { 'title' => 'Reporting Bugs',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1055074823,
          'read?' => false,
          'desc'  => 'Reporting Bugs .
============== .
Please make sure you\'re using the latest version of Raggle before
reporting bugs.  That said, you can submit bug reports to
ragglebug@pablotron.org.
', },
      ],
    },
    { 'title'     => 'Alternet',
      'url'       => 'http://www.alternet.org/rss/rss.xml',
      'site'      => 'http://www.alternet.org/',
      'desc'      => 'Alternative News and Information.',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Anandtech (NiF)',
      'url'       => 'http://www.newsisfree.com/HPE/xml/feeds/61/161.xml',
      'site'      => 'http://www.anandtech.com/',
      'desc'      => 'Anandtech',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Consensus at Lawyerpoint',
      'url'       => 'http://bpdg.blogs.eff.org/index.rdf',
      'site'      => 'http://www.eff.org/',
      'desc'      => 'Consensus at Lawyerpoint',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Creative Commons',
      'url'       => 'http://creativecommons.org/weblog/rss',
      'site'      => 'http://creativecommons.org/',
      'desc'      => 'Creative Commons',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Daily Daemon News',
      'url'       => 'http://daily.daemonnews.org/ddn.rdf.php3',
      'site'      => 'http://daemonnews.org/',
      'desc'      => 'Daily Daemon News',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Digital Theatre',
      'url'       => 'http://www.dtheatre.com/backend.php?xml=yes',
      'site'      => 'http://www.dtheatre.com/',
      'desc'      => 'Digital Theatre',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'EFF News (NiF)',
      'url'       => 'http://www.newsisfree.com/HPE/xml/feeds/22/3222.xml',
      'site'      => 'http://www.eff.org/',
      'desc'      => 'EFF News.',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Exploding Cigar',
      'url'       => 'http://www.explodingcigar.com/backend.xml',
      'site'      => 'http://www.explodingcigar.com/',
      'desc'      => 'Exploding Cigar',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'FlipCode (NiF)',
      'url'       => 'http://www.newsisfree.com/HPE/xml/feeds/08/208.xml',
      'site'      => 'http://www.flipcode.org/',
      'desc'      => 'FlipCode.',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'FreshMeat',
      'url'       => 'http://themes.freshmeat.net/backend/fm-newsletter.rdf',
      'site'      => 'http://www.freshmeat.net/',
      'desc'      => 'FreshMeat.',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'KernelTrap',
      'url'       => 'http://kerneltrap.org/module.php?mod=node&op=feed',
      'site'      => 'http://www.kerneltrap.org/',
      'desc'      => 'KernelTrap',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Kuro5hin',
      'url'       => 'http://www.kuro5hin.org/backend.rdf',
      'site'      => 'http://www.kuro5hin.org/',
      'desc'      => 'Kuro5hin',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Leoville',
      'url'       => 'http://www.leoville.com/mt/index.xml',
      'site'      => 'http://www.leoville.com/',
      'desc'      => 'Leoville',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Linux Magazine',
      'url'       => 'http://www.linux-mag.com/lm.rss',
      'site'      => 'http://www.linux-mag.com/',
      'desc'      => 'Linux Magazine',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Linux Weekly News',
      'url'       => 'http://www.lwn.net/headlines/rss',
      'site'      => 'http://www.lwn.net/',
      'desc'      => 'Linux Weekly News',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'MetaFilter',
      'url'       => 'http://xml.metafilter.com/rss.xml',
      'site'      => 'http://www.metafilter.com/',
      'desc'      => 'MetaFilter',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'MovieComments',
      'url'       => 'http://www.moviecomments.com/recentrev_rss.php',
      'site'      => 'http://www.moviecomments.com/',
      'desc'      => 'MovieComments',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'MTV News (NiF)',
      'url'       => 'http://www.newsisfree.com/HPE/xml/feeds/92/1792.xml',
      'site'      => 'http://www.mtv.com/',
      'desc'      => 'MTV News (NiF)',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'O\'Reilly Network',
      'url'       => 'http://www.oreillynet.com/cs/xml/query/q/295?x-ver=1.0',
      'site'      => 'http://www.oreillynet.com/',
      'desc'      => 'O\'Reilly Network',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Open Sounds',
      'url'       => 'http://www.opensounds.net/backend.php',
      'site'      => 'http://www.opensounds.net/',
      'desc'      => 'John Maguire.',
      'refresh'   => 60,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'PHP Journal',
      'url'       => 'http://www.phpj.com/backend.php',
      'site'      => 'http://www.phpj.com/',
      'desc'      => 'PHP Journal',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Pigdog Journal',
      'url'       => 'http://www.pigdog.org/pigdog.rdf',
      'site'      => 'http://www.pigdog.org/',
      'desc'      => 'Pigdog Journal',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Political Wire',
      'url'       => 'http://politicalwire.com/headlines.xml',
      'site'      => 'http://politicalwire.com/',
      'desc'      => 'Political Wire',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Slashdot',
      'url'       => 'http://slashdot.org/slashdot.rss',
      'site'      => 'http://www.slashdot.org/',
      'desc'      => 'Slashdot',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'This Modern World',
      'url'       => 'http://www.thismodernworld.com/index.rdf',
      'site'      => 'http://www.thismodernworld.com/',
      'desc'      => 'This Modern World',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Universal Rule',
      'url'       => 'http://radio.weblogs.com/0112083/rss.xml',
      'site'      => 'http://radio.weblogs.com/0112083/',
      'desc'      => 'Universal Rule',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'use Perl',
      'url'       => 'http://use.perl.org/useperl.rdf',
      'site'      => 'http://use.perl.org/',
      'desc'      => 'Universal Rule',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'W3C',
      'url'       => 'http://www.w3.org/2000/08/w3c-synd/home.rss',
      'site'      => 'http://www.w3.org/',
      'desc'      => 'W3C',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
    { 'title'     => 'Webmonkey',
      'url'       => 'http://radio.weblogs.com/0112083/rss.xml',
      'site'      => 'http://radio.weblogs.com/0112083/',
      'desc'      => 'Webmonkey',
      'refresh'   => 30,
      'updated'   => 1055113783,
      'items'     => [ ],
    },
  ],

  # debugging / internal options (don't touch)
  'use_raw_mode'  => true,
  'use_noecho'    => true,

  # debugging feeds (these will be removed at some point)
  'debug_feeds'   => [ ],
}

class String
  def escape
    gsub(/(["\\])/, "\\$1")
  end

  def escape!
    gsub!(/(["\\])/, "\\$1")
  end

  # this bit of love is from the pickaxe
  def unescape_html
    str = self.dup
    str.gsub!(/&(.*?);/n) {
      m = $1.dup
      case m
      when /^amp$/ni
        '&'
      when /^nbsp$/ni
        ' '
      when /^quot$/ni
        '"'
      when /^lt$/ni
        '<'
      when /^gt$/ni
        '>'
      when /^#8212$/n
        ","
      when /^#8217$/n
        "'"
      when /^#(\d+)$/n
        r = Integer($1)
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      when /^#x([0-9a-f]+)$/ni
        r = $1.hex
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      end
    }
    str
  end

  def strip_tags
    gsub(/<[^>]+?>/, '')
  end
end

module Feed
  # Feed::Item struct definition
  Item = Struct.new :title, :link, :desc, :date

  #
  # Return the contents of a URL
  #
  def Feed::get_url(url)
    port = 80
    use_ssl = false

    if url =~ /^https:/
      raise 'HTTPS support requires OpenSSL-Ruby' unless $HAVE_SSL
      use_ssl = true
    end

    # strip 'http://' prefix from URL
    url.gsub!(/^\w+?:\/\//, '') if url =~ /^\w+?:\/\//

    # get host and path portions of url
    raise "Couldn't parse URL: \"#{url}\"" unless url =~ /^(.+?)\/(.*)$/
    host, path = $1, $2

    # check for port in url
    if host =~ /:(\d+)$/
      port = $1 
      host.gsub!(/:(\d+)$/, '')
    end

    # init http connection
    http = Net::HTTP.start(host, port)
    http.use_ssl = use_ssl if $HAVE_SSL
    raise "Couldn't connect to host \"#{host}:#{port}\"" unless http

    # get result
    resp, ret = nil, ''
    begin
      resp, ret = http.get('/' << path)
    rescue 
      resp = $!.response

      # handle redirects
      if resp.code =~ /3\d{2}/
        ret = get_url resp['Location']
      else
        raise "HTTP Error: #$!"
      end
    end

    # close HTTP connection
    # Note: if we don't specify this, then the connection is pooled for the
    # HTTP/1.1 spec (do we prefer that kind of behavior?  maybe I should make in
    # an option)
    http.finish

    # return URL content
    ret
  end

  class Channel
    attr_accessor :title, :link, :desc, :lang, :items

    def initialize(url)
      parse_rss_url url
    end
      
    # 
    # Parse an RSS URL and return a FeedChannel object (which contains,
    # among other things, an array of feed_item structs)
    #
    def parse_rss_url(url)
      begin
        content = Feed::get_url url
      rescue
        raise "Couldn't get URL \"#{url}\": #$!."
      end

      # parse URL content
      doc = REXML::Document.new content

      # get channel info
      e = nil
      @title = e.text if e = doc.root.elements['//channel/title']
      @link = e.text if e = doc.root.elements['//channel/link']
      @desc = e.text if e = doc.root.elements['//channel/description']
      @lang = e.text if e = doc.root.elements['//channel/language']
  
      # build list of feed items
      @items = []
      doc.root.elements.each('//item') { |e| 
        # get item attributes (the ones that are set, anyway... stupid
        # RSS)
        h = {}
        [ 'title', 'link', 'description', 'date' ].each { |val|
          h[val] = (t_e = e.elements[val]) ? t_e.text : ''
        }

        # insert new item
        @items << Feed::Item.new(h['title'], h['link'],
                                 h['description'], h['date'])
      }
    end
  end
end


class Window
  attr_accessor :win, :win_type, :title, :key, :colors, :active, :items, :active_item, :offset

  #
  # window constructor
  #
  def initialize(opts)
    coords = opts['coords'].dup
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    @active_item = 0
    @offset = 0
    @items = []

    @title = opts['title']
    @win_type = opts['type']
    @key = opts['key']
    @colors = opts['colors'].dup

    @win = Ncurses::newwin coords[3], coords[2], coords[1], coords[0]
    refresh
  end

  #
  # refresh window title and border (but not the contents)
  # 
  def refresh(refresh_contents = false)
    win.color_set @colors[@active ? 'a_box' : 'box'], nil
    Ncurses::box win, 0, 0
    win.color_set @colors[@active ? 'a_title' : 'title'], nil
    Ncurses::mvwprintw win, 0, 1, " #{@title} "
    win.color_set @colors['text'], nil
    Ncurses::wrefresh win
  end

  def clear
    @win.color_set @colors['text'], nil
    @win.clear
  end

  #
  # draw text in window
  #
  def draw(orig_text, x = 1, y = 1, color = 'text', refresh_win = true, reflow_text = true)
    ha = []; wa = []
    Ncurses::getmaxyx win, ha, wa
    w, h = wa[0], ha[0]

    # reflow text if it's a text window
    # DOES THIS BELOGN HERE?
    if reflow_text && @win_type == 'text'
      text = ''
      curr_line = ''
      orig_text.split(/\s+/).each { |word|
        if word == '.'
          text << curr_line << "\n" 
          curr_line = ''
        elsif curr_line.length + word.length > w - 2
          text << curr_line << "\n"
          curr_line = "#{word} "
        else
          curr_line += "#{word} "
        end
      }
      text << curr_line << "\n"
    else
      text = orig_text
    end

    # draw text in window
    @win.color_set @colors[color], nil if color != 'text'
    text.each_line { |line|
      Ncurses::mvwprintw @win, y, x, line.slice(0, w - x - 1)
      y += 1
    }
    @win.color_set @colors['text'], nil

    refresh if refresh_win
  end

  # get window width and height
  def dimensions
    ha = []; wa = []
    Ncurses::getmaxyx @win, ha, wa
    [wa[0], ha[0]]
  end

  #
  # Adjust the window to show the selected item
  #
  def adjust_to(item)
    # scroll window (if necessary)
    w, h = dimensions
    if item < @offset || item >= @offset + (h - 3)
      @offset = @active_item
      @offset = 0 if @offset < 0
      if item + h - 3 > @items.size - 1
        @offset = @active_item - (h - 3)
        @offset = 0 if @offset < 0
      end
    end
    draw_items
    
    # Should I really have put this here? -- richlowe 2003-06-19
    status = ' ' << @items[@active_item]['title']
    status = status.split(/\s+/).join(' ')
    set_status status

    select_win_item if $config['focus'] == 'auto'
  end

  #
  # Bound scrolling based on $config['scroll_wrapping']
  #
  def scroll_bound(point)
    if point >= @items.size
      $config['scroll_wrapping'] ? 0 : @items.size - 1
    elsif point < 0
      $config['scroll_wrapping'] ? @items.size - 1 : 0
    else
      point
    end
  end

  #
  # Activate an item
  #
  def activate(item)
    @active_item = item
    adjust_to item
  end
  
  #
  # Scroll the window up one item
  #
  def scroll_up
    activate scroll_bound(@active_item - 1)
  end
  
  #
  # Scroll window down.
  #
  def scroll_down
    activate scroll_bound(@active_item + 1)
  end
  
  #
  # Scroll to the bottom.
  #
  def scroll_bottom
    activate @items.size - 1
  end

  #
  # Scroll to the top item
  #
  def scroll_top
    activate 0
  end

  #
  # Scroll one page up.
  #
  def scroll_up_page
    activate scroll_bound((@active_item - $config['page_step']) % @items.size)
  end

  #
  # Scroll one page down.
  #
  def scroll_down_page
    activate scroll_bound((@active_item + $config['page_step']) % @items.size)
  end
       
  #
  # handle keyboard input
  #
  def handle_key(key)
    case key
    when Ncurses::KEY_UP 
      scroll_up
    when Ncurses::KEY_DOWN
      scroll_down
    when Ncurses::KEY_END
      scroll_bottom
    when Ncurses::KEY_HOME
      scroll_top
    when Ncurses::KEY_PPAGE
      scroll_up_page
    when Ncurses::KEY_NPAGE
      scroll_down_page
    when ?\n
      select_win_item
    when ?\ 
      select_win_item
    end
  end

  #
  # select currently hilited window item
  #
  def select_win_item
    if @items && @items.size > 0
      if @items[@active_item].has_key? 'feed'
        select_feed @items[@active_item]['feed']
      elsif @items[@active_item].has_key? 'item'
        select_item @items[@active_item]['item']
      elsif @items[@active_item].has_key? 'url'
        # are we opening new screen windows?
        use_screen = $config['use_screen'] && in_screen?

        # drop out of curses mode
        unless use_screen
          Ncurses::def_prog_mode
          Ncurses::endwin
        end

        # get browser command
        cmd = $config['browser_cmd'] % @items[@active_item]['url'].escape

        # prepend screen command if we're using it
        if use_screen
          screen_cmd = if $config['screen_cmd'] =~ /%s/
            $config['screen_cmd'] % @items[@active_item]['real_title']
          else
            $config['screen_cmd']
          end

          # build new command
          cmd = screen_cmd << ' ' << cmd
        end
        
        # execute command
        system cmd

        # reset screen
        unless use_screen
          Ncurses::reset_prog_mode
          Ncurses::refresh
        end
      end
    end
  end

  #
  # redraw window items
  #
  def draw_items
    y = 0
    if @win_type == 'text'
      @items.each { |item|
        y += 1
        draw("Link: ", 1, y)
        # @win.color_set @colors['url'], nil
        draw(item['url'], 7, y, 'url', true, false)

        # don't draw the date if it isn't set (silly RSS)
        if item['date'] && item['date'] != ''
          y += 1
          draw("Date: ", 1, y)

          # handle date string shenanigans
          if ((i_val = item['date'].to_i) > 0)
            d_str = Time.at(i_val).strftime($config['desc_date_format'])
          else
            d_str = item['date']
          end

          # draw date string
          # @win.color_set @colors['date'], nil
          draw(d_str, 7, y, 'date', true, false)
        end
        str = item['title'].strip_tags if $config['strip_html_tags']
        str = str.unescape_html if $config['unescape_html']
        draw(str, 1, y += 2)
      }
    else
      w, h = dimensions
      ic = 0
      @items.each { |i| 
        t = i['title'] || ''
        text = t + ((t.length < w) ? (' ' * (w - t.length)) : '')
        if i.has_key?('read?') && i['read?'] == false
          color = (ic == @active_item) ? 'h_unread' : 'unread'
        else
          color = (ic == @active_item) ? 'h_text' : 'text'
        end

        draw(text, 1, y += 1, color) if ic >= @offset
        ic += 1
      }
    end
    refresh(true)
  end
end

#
# set status bar message
#
def set_status(str)
  w, e_msg = $config['w'], $config['msg_exit']
  $status, $new_status = str, str

  # fix message length
  if str.length > (w - e_msg.length)
    str = str.slice(0, w - e_msg.length)
  else
    str += ' ' * (w - e_msg.length - str.length)
  end
  msg = str << e_msg

  Ncurses::stdscr.color_set $config['theme']['status_bar_cols'], nil
  Ncurses::mvprintw $config['h'], 0, msg
  Ncurses::refresh
end

# 
# set active window 
#
def set_active_win(a_win)
  $wins[$a_win].active = false
  $wins[$a_win].refresh

  $a_win = a_win

  $wins[$a_win].active = true
  $wins[$a_win].refresh
end

#
# get window id by key
#
def get_win_id(str)
  $wins.each_index { |i| return i if $wins[i].key == str }
  -1
end


# 
# expand path macros in $config
#
def expand_config
  $config.each { |key, val| 
    next unless val.class == String && val =~ /\${(.+?)}/
    orig_val = val.dup
    val.gsub!(/\${(.+?)}/, $config[$1])
    # puts "\"#{orig_val}\" expands to \"#{val}\""
  }
end

#
# set active feed by id
#
def select_feed(id)
  $a_feed = id
  $a_item = 0

  # clear item window
  item_id = get_win_id 'item'
  $wins[item_id].active_item = 0
  $wins[item_id].items.clear

  # unused.. remove it?
  fmt = $config['item_date_format']

  # wtf is happening here?
  raise "id.class.to_s = #{id.class.to_s}" unless id.class == Fixnum
  
  # iterate through feed items
  $config[$SRC][id]['items'].each_with_index { |item, i|
    # can't depend on the date being in a consistent format, or
    # being defined at all, for that matter :( :( :(
    # title = item['title'] + ' (' +
    #         Time.at(item['date'].to_i).strftime(fmt) << ')'

    # build title string
    if item['date'] && item['date'].size > 0
      d_str = item['date']
      d_str = Time.at(item['date'].to_i).strftime(fmt) if item['date'].to_i > 0
      title = "#{item['title']} (#{d_str})"
    elsif item['title'] !~ /^\s*$/ 
      title = item['title'].dup
    elsif item['desc'] !~ /^\s*$/ 
      # fall back on cleaned up and truncated description if we're
      # missing a title
      w, h = $wins[item_id].dimensions
      title = item['desc'].dup.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    else
      # if title is garbage and we have no description, then fall back
      # on formatted and truncated link (silly broken RSS feeds)
      title = '[' << item['url'].dup << ']'

      w, h = $wins[item_id].dimensions
      title = title.dup.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    end

    $wins[item_id].items << {
      'title' => title,
      'item'  => i,
      'read?' => item['read?']
    }
  }

  # redraw item window
  $wins[item_id].win.clear
  $wins[item_id].draw_items

  # activate item window
  set_active_win(item_id) if $config['focus'] == 'select'
end

#
# populate feed window
# 
def populate_feed_win 
  id = get_win_id 'feed'

  $wins[id].items.clear

  $config[$SRC].each_with_index { |feed, i|
    # count unread items
    unread_count = 0
    feed['items'].each { |item| unread_count += 1 unless item['read?'] }

    # build title
    title = feed['title'] + " (#{unread_count}/#{feed['items'].size})"
    $wins[id].items << {
      'title' => title,
      'feed'  => i,
    }
  }
  $wins[id].draw_items
end

#
# set active item by id
#
def select_item(id)
  $a_item = id

  desc_id = get_win_id 'desc'
  item_id = get_win_id 'item'

  # clear description window
  $wins[desc_id].active_item = 0
  $wins[desc_id].items.clear

  # mark item as read
  $wins[item_id].items[$a_item]['read?'] = true
  $config[$SRC][$a_feed]['items'][id]['read?'] = true

  # load item
  $wins[desc_id].items << {
    'title'       => $config[$SRC][$a_feed]['items'][id]['desc'],
    'real_title'  => $config[$SRC][$a_feed]['items'][id]['title'],
    'url'         => $config[$SRC][$a_feed]['items'][id]['url'],
    'date'        => $config[$SRC][$a_feed]['items'][id]['date'],
    'read?'       => $config[$SRC][$a_feed]['items'][id]['read?'],
  }

  # redraw feed window
  populate_feed_win

  # redraw description window
  $wins[desc_id].win.clear
  $wins[desc_id].draw_items

  # activate description window
  set_active_win(desc_id) if $config['focus'] == 'select' and
                             !$config['no_desc_auto_focus']
end

#
# load feed cache
#
def load_feed_cache
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config[$SRC].each { |feed|
      feed['items'] = s.root?(feed['url']) ? s[feed['url']] : []
    }
  }
end

#
# save feed cache 
#
def save_feed_cache
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config[$SRC].each { |feed| s[feed['url']] = feed['items'] }
  }
end

#
# old save feed cache 
#
def old_save_feed_cache
  File::open($config['feed_cache_path'], 'w') { |f|
    $stdout.puts $config['msg_save_feeds']
    $stdout.flush
    f.puts $config[$SRC].to_yaml
  }
end

#
# save feed list 
#
def save_feed_list
  File::open($config['feed_list_path'], 'w') { |f|
    $stdout.puts $config['msg_save_list'] if $config['raggle_mode'] == 'view'
    $stdout.flush
    $config[$SRC].each { |feed| feed['items'].clear }
    f.puts $config[$SRC].to_yaml
  }
end

#
# save theme
#
def save_theme
  File::open($config['theme_path'], 'w') { |f|
    $stdout.puts $config['msg_save_theme']
    $stdout.flush
    f.puts $config['theme'].to_yaml
  }
end

#
# handle mouse events
#
def handle_mouse(ev) 
  puts 'mouse'
end

def print_usage
  puts <<ENDUSAGE
Raggle - Console RSS feed aggregator.
Version #$VERSION, by Paul Duncan <pabs@pablotron.org>

Usage:
  #$0 [options]

Options:
  -a, --add, --add-feed         Add a new feed (requires '--title', '--url',
                                and '--refresh').
  -c, --config                  Specify an alternate config file.
  -d, --delete, --delete-feed   Delete an existing feed.
  -e, --edit, --edit-feed       Edit an existing feed.
  -h, --help, --usage           Display this usage screen.
  -l, --list                    List existing feeds (use '--verbose' to 
                                show URLs as well).
  -r, --refresh                 Refresh attribute of feed (for '--add' and
                                '--edit').
  -t, --title                   Title attribute of feed (for '--add' and
                                '--edit').
  -u, --url                     URL attribute of feed (for '--add' and
                                '--edit').
  --verbose                     Turn on verbose output.
  -v, --version                 Display version information.

Examples:
  # add a new feed, refresh every 30 minutes
  #$0 -a -t 'test feed' -u http://www.example.com/feed.rss -r 30

  # list feeds and their ids
  #$0 --list

  # delete an existing feed
  #$0 --delete 12

  # set the title and refresh of an existing feed
  #$0 --edit 10 --title 'hi there!' -r 20
  
About the Author:
Paul Duncan <pabs@pablotron.org>
http://www.pablotron.org/
ENDUSAGE

  exit 0
end

#
# handle command-line options
# 
def handle_Command_line(opts)
  ret = { 'mode' => 'view' }
  grab_next = 0

  0.upto(opts.size - 1) { |i|
    if grab_next > 0
      grab_next -= 1
      next
    end
    
    case opts[i]
    when '-a'
      ret['mode'] = 'add'
    when '--add'
      ret['mode'] = 'add'
    when '--add-feed'
      ret['mode'] = 'add'
    when '-e'
      ret['mode'] = 'edit'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '--edit'
      ret['mode'] = 'edit'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '--edit-feed'
      ret['mode'] = 'edit'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '-d'
      ret['mode'] = 'delete'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '--delete'
      ret['mode'] = 'delete'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '--delete-feed'
      ret['mode'] = 'delete'
      grab_next = 1
      ret['id'] = opts[i + 1]
    when '-l'
      ret['mode'] = 'list'
    when '--list'
      ret['mode'] = 'list'
    when '-c'
      grab_next = 1
      $config['config_path'] = opts[i + 1]
    when '--config'
      grab_next = 1
      $config['config_path'] = opts[i + 1]
    when '--config-file'
      grab_next = 1
      $config['config_path'] = opts[i + 1]
    when '-t'
      grab_next = 1
      ret['title'] = opts[i + 1]
    when '--title'
      grab_next = 1
      ret['title'] = opts[i + 1]
    when  '-u'
      grab_next = 1
      ret['url'] = opts[i + 1]
    when '--url'
      grab_next = 1
      ret['url'] = opts[i + 1]
    when '-r'
      grab_next = 1
      ret['refresh'] = opts[i + 1].to_i
    when '--refresh'
      grab_next = 1
      ret['refresh'] = opts[i + 1].to_i
    when '-v'
      puts "Raggle v#$VERSION"
      exit 0
    when '--version'
      puts "Raggle v#$VERSION"
      exit 0
    when '--verbose'
      $config['verbose'] = true
    when '-h'
      print_usage
    when '--help'
      print_usage
    when '--usage'
      print_usage
    else
      $stderr.puts 'Unknown option: ' << opts[i]
      exit -1
    end
  }

  # check options
  if ret['mode'] == 'add'
    ['title', 'url', 'refresh'].each { |val|
      unless ret[val]
        die "Missing '--#{val}'."
        exit -1
      end
    }
  elsif ret['mode'] == 'edit'
    unless ret['title'] || ret['url'] || ret['refresh']
      die "You need '--title', '--url', or '--refresh'."
    end
  end

  # return options
  ret
end

def list_feeds
  i = -1
  if $config['verbose']
    puts 'ID, Title, URL, Refresh'
    $config[$SRC].each { |feed|
     puts "%2d, #{feed['title']}, #{feed['url']}, #{feed['refresh']}" % (i += 1)
    }
  else 
    puts 'ID, Title'
    $config[$SRC].each { |feed|
     puts "%2d, #{feed['title']}" % (i += 1)
    }
  end
end

def add_feed(opts)
  $config[$SRC] << {
    'title'     => opts['title'],
    'url'       => opts['url'],
    'site'      => '',
    'desc'      => '',
    'refresh'   => opts['refresh'],
    'updated'   => 1,
    'items'     => [ ],
  }
end

def delete_feed(id)
  die "Unknown feed id #{id}." unless $config[$SRC].delete_at(id)
end

def edit_feed(id, opts)
  %w{title url refresh}.each { |key|
    $config[$SRC][id][key] = opts[key] if opts.has_key? key
  }
end

def create_cache_lock
  path = $config['cache_lock_path']
  
  # open cache lock for writing
  unless $config['cache_lock'] = File::open(path, 'w')
    die "Couldn't open \"#{path}\"."
  end

  # obtain cache lock
  unless $config['cache_lock'].flock(File::LOCK_EX | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't obtain cache lock: " << 
                 "Another instance of Raggle is running.\n"
    $stderr.puts "WARNING: Disabling feed caching for this instance."
    $stderr.puts "WARNING: Press enter to continue."

    # wait for user response
    $stdin.gets

    # disable feed caching and theme saving
    $config['use_cache_lock'] = false
    $config['save_feed_list'] = false
    $config['save_feed_cache'] = false
    $config['save_theme'] = false
  end
end

def destroy_cache_lock
  path = $config['cache_lock_path']

  # unlock cache lock
  unless $config['cache_lock'].flock(File::LOCK_UN | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end

  # close cache lock
  $config['cache_lock'].flush
  $config['cache_lock'].close
  $config['cache_lock'] = nil

  # start garbage collection (flush out file descriptor)
  GC.start

  # unlink cache lock
  unless File::unlink(path)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end
end

#######################################################################
# End Shenanigans, Begin Actual Code                                  #
#######################################################################

# expand the default config hash
expand_config

# parse command-line options
opts = handle_Command_line ARGV

# if $HOME/.raggle doesn't exist, then create it
Dir::mkdir $config['config_dir'] unless test ?d , $config['config_dir']

# load user config ($HOME/.raggle/config.rb)
puts $config['msg_load_config'] if opts['mode'] == 'view'
load $config['config_path'], false if test ?e, $config['config_path']
expand_config

# load feed list
puts $config['msg_load_list'] if opts['mode'] == 'view'
if $config['load_feed_list'] && test(?e, $config['feed_list_path'])
  $config[$SRC] = YAML::load(File::open($config['feed_list_path']))
end

# create cache lock
create_cache_lock if $config['use_cache_lock']

# handle command-line options
$config['raggle_mode'] = opts['mode']
case opts['mode']
when 'list'
  list_feeds
  exit 0
when 'add'
  add_feed opts
  save_feed_list
  exit 0
when 'delete'
  delete_feed opts['id'].to_i
  save_feed_list
  exit 0
when 'edit'
  edit_feed opts['id'].to_i, opts
  save_feed_list
  exit 0
end

# load feed cache
load_feed_cache if $config['load_feed_cache'] &&
                   test(?e, $config['feed_cache_path'])

# load theme
puts $config['msg_load_theme']
if $config['load_theme'] && test(?e, $config['theme_path'])
  $config['theme'] = YAML::load(File::open($config['theme_path']))
end

# start feed grabbing thread
feed_thread = Thread.new {
  File.open($config['grab_log_path'], $config['grab_log_mode']) { |log|
    log.puts "#{Time.now}: Starting grab log."
    loop {
      $config[$SRC].each { |feed|
        t = Time.now

        $new_status = " Checking feed \"#{feed['title']}\"..."
        log.puts "#{Time.now}: Checking feed \"#{feed['title']}\""
        next unless feed['refresh'] > 0 && 
                    feed['updated'] + (feed['refresh'] * 60) < t.to_i

        # update statusbar and grab log
        $new_status = " Updating feed \"#{feed['title']}\"..."
        log.puts "#{t}: Updating feed \"#{feed['title']}\" from \"#{feed['url']}\""
        # set_status "Updating \"#{feed['title']}\"..."

        # TODO: save old items
        # old_items = feed['items']
        
        # get channel
        begin
          chan = Feed::Channel.new(feed['url'])
        rescue
          # set_status "Error updating \"#{feed['title']}\"."
          log.puts "#{t}: Error: #$!"
          next
        end

        # update feed attributes
        feed['title'] = chan.title
        feed['site'] = chan.link
        feed['updated'] = t.to_i

        # clear feed list
        feed['items'].clear

        # insert new items
        chan.items.each { |item|
          feed['items'] << {
            'title' => item.title,
            'date'  => item.date,
            'url'   => item.link,
            'desc'  => item.desc,
            'read?' => false,
          }
        }

        # redraw feed / item windows
        $update_windows = true
      }

      # finish log entries
      interval = $config['feed_sleep_interval']
      $new_status = $config['msg_welcome']
      log.puts "#{Time.now}: Done checking.  Sleeping for #{interval}s."
      log.flush
      sleep interval
    }
  }
}

begin
  # initialize screen & keyboard
  Ncurses::initscr
  Ncurses::raw if $config['use_raw_mode']
  Ncurses::keypad Ncurses::stdscr, 1
  Ncurses::noecho if $config['use_noecho']
  Ncurses::start_color
  # Ncurses::mousemask(Ncurses::ALL_MOUSE_EVENTS, [])

  # exit -1 unless Ncurses::has_colors?

  # initialize color pairs
  $config['color_palette'].each { |ary| Ncurses::init_pair *ary }

  # get screen coordinates
  h = []; w = []
  Ncurses::getmaxyx Ncurses::stdscr, h, w
  $config['w'] = w[0]
  $config['h'] = h[0] - 1

  # draw menu bar
  # c_msg = $config['msg_close']
  # msg = (' ' * ($config['w'] - c_msg.length)) << c_msg
  # Ncurses::wcolor_set Ncurses::stdscr, $config['menu_bar_cols'], nil
  # Ncurses::mvprintw 0, 0, msg
  # Ncurses::refresh

  # draw status bar
  $new_status = ''
  set_status $config['msg_welcome']
  
  # create windows
  $a_win = 0
  $wins = []
  ['feed', 'item', 'desc'].each { |i|
    $wins << Window.new($config['theme']["win_#{i}"])
    # $wins[-1].draw LONG_STRING
  }
  set_active_win(0)
  
  $a_feed, $a_item = 0, 0
  
  # populate feed window
  populate_feed_win
  
  select_feed(0)
  set_active_win(0)
  
  # main input loop
  timeout = $config['input_select_timeout']
  done = false
  until done
    # handle keyboard input
    r = select [$stdin], nil, nil, timeout
    if r && r.size > 0
      case c = Ncurses::getch
      when Ncurses::KEY_RIGHT
        set_active_win(($a_win + 1) % $wins.size)
      when ?\t
        set_active_win(($a_win + 1) % $wins.size)
      when Ncurses::KEY_LEFT
        set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
      when ?\\
        set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
      when Ncurses::KEY_F12
        done = true
      when Ncurses::KEY_MOUSE
        ev_a = []
        handle_mouse(ev_a[0]) if Ncurses::getmouse(ev_a) == Ncurses::OK
      when ?q
        done = true
      else  
        $wins[$a_win].handle_key c
      end
    end

    # refresh window contents if there's been a feed update
    if $update_wins
      $update_wins = false
      populate_feed_win
      # wins.each { |win| win.draw_items }
    end

    set_status $new_status if $new_status != $status
  end
ensure
  # clean up screen on exit
  Ncurses::endwin

  # stop feed grabbing thread
  feed_thread.exit

  # save feed cache
  save_feed_cache if $config['save_feed_cache']

  # save feed list
  save_feed_list if $config['save_feed_list']

  # save theme
  save_theme if $config['save_theme']

  # unlock everything
  destroy_cache_lock if $config['use_cache_lock'] && $config['cache_lock']

  $stdout.puts $config['msg_thanks']
end
