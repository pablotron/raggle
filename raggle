#!/usr/bin/env ruby
# -*- Mode: Ruby -*-

#######################################################################
# Raggle - Console RSS aggregator                                     #
# by Paul Duncan <pabs@pablotron.org> and                             #
#    Richard Lowe <richlowe@richlowe.net>                             #
#                                                                     #
#                                                                     #
# Please see the Raggle page at                                       #
# http://www.pablotron.org/software/raggle/ for the latest version of #
# this software.                                                      #
#                                                                     #
#                                                                     #
# Copyright (C) 2003 Paul Duncan, and various contributors.           #
#                                                                     #
# Permission is hereby granted, free of charge, to any person         #
# obtaining a copy of this software and associated documentation      #
# files (the "Software"), to deal in the Software without             #
# restriction, including without limitation the rights to use, copy,  #
# modify, merge, publish, distribute, sublicense, and/or sell copies  #
# of the Software, and to permit persons to whom the Software is      #
# furnished to do so, subject to the following conditions:            #
#                                                                     #
# The above copyright notice and this permission notice shall be      #
# included in all copies of the Software, its documentation and       #
# marketing & publicity materials, and acknowledgment shall be given  #
# in the documentation, materials and software packages that this     #
# Software was used.                                                  #
#                                                                     #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  #
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND               #
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY    #
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF          #
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  #
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.     #
#######################################################################

# Raggle version
$VERSION = '0.2.0'

# As early as possible, ^C and ^\ are common, and dumping a trace is ugly
trap('INT') { puts "Interrupted"; exit -1 }
trap('QUIT') { puts "Quit"; exit -1 }

# load required modules
require 'getoptlong'
require 'ncurses'
require 'net/http'
require 'pstore'
require 'rexml/document'
require 'yaml'

begin 
  require 'net/https'
  $HAVE_SSL = true
rescue LoadError
  $HAVE_SSL = false
end

###################
# utility methods #
###################


#
# I like die
#
def die(str)
  errstr = "#$0: FATAL: #{str}"
  errstr += ": #$!" if $!
  $stderr.puts errstr
  exit -1
end

module Path
  #
  # find an application in your $PATH
  #
  def Path::find_app(app)
    ENV['PATH'].split(/:/).find { |path| test ?x, "#{path}/#{app}" }
  end
  
  #
  # Find browser
  #
  def Path::find_browser
    ret = ENV['RAGGLE_BROWSER']
    ret = ENV['BROWSER']
    ret = 'links' if !ret && test(?e, find_app('links'))
    ret = 'w3m' if !ret && test(?e, find_app('w3m'))
    ret = 'lynx' if !ret && test(?e, find_app('lynx'))
    
    # die if we couldn't find a browser
    die "Couldn't find suitable browser.  Is $BROWSER set?" unless ret
    
    # return browser
    ret
  end
end

# 
# Are we running in a screen session?
#
def in_screen?
  ENV['WINDOW'] != nil
end

class String
  def lines
    self.split(/\n/).size
  end
  
  def escape
    gsub(/(["\\])/, "\\$1")
  end

  def escape!
    gsub!(/(["\\])/, "\\$1")
  end

  # this bit of love is from the pickaxe
  def unescape_html
    str = self.dup
    str.gsub!(/&(.*?);/n) {
      m = $1.dup
      case m
      when /^amp$/ni
        '&'
      when /^nbsp$/ni
        ' '
      when /^quot$/ni
        '"'
      when /^lt$/ni
        '<'
      when /^gt$/ni
        '>'
      when /^#8212$/n
        ","
      when /^#8217$/n
        "'"
      when /^#(\d+)$/n
        r = Integer($1)
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      when /^#x([0-9a-f]+)$/ni
        r = $1.hex
        r.between?(0, 255) ? r.chr : $config['unicode_munge_str']
      end
    }
    str
  end

  def strip_tags
    gsub(/<[^>]+?>/, '')
  end

  def reflow(width = 72, force = false, line_delim_regex = /^(<br[^\/]*>|\.)$/)
    text = ''
    curr_line = ''
    strip.split(/\s+/).each { |word|
      if line_delim_regex && word =~ line_delim_regex
        text << curr_line << "\n" 
        curr_line = ''
      elsif curr_line.length + word.length > width
        if curr_line.length > width and force
          fline = curr_line[0, width - 2] << "\\\n"
          text << fline
          curr_line = curr_line[width - 2, curr_line.length]
        else
          text << curr_line << "\n"
          curr_line = "#{word} "
        end
      else
        curr_line << "#{word} "
      end
    }
    text << curr_line << "\n"
    text
  end
end

module Key
  def Key::scroll_up
    $wins[$a_win].scroll_up
  end

  def Key::scroll_down
    $wins[$a_win].scroll_down
  end

  def Key::scroll_top
    $wins[$a_win].scroll_top
  end

  def Key::scroll_bottom
    $wins[$a_win].scroll_bottom
  end

  def Key::scroll_up_page
    $wins[$a_win].scroll_up_page
  end

  def Key::scroll_down_page
    $wins[$a_win].scroll_down_page
  end

  def Key::quit
    $done = true
  end

  def Key::next_window
    set_active_win(($a_win + 1) % $wins.size)
  end

  def Key::prev_window
    set_active_win((($a_win - 1 < 0) ? $wins.size : $a_win) - 1)
  end

  def Key::select_item
    $wins[$a_win].select_win_item
  end

  def Key::move_item_up
    win = $wins[get_win_id('feed')]
    $config['feeds'].move_up(win.active_item)
    win.move_item_up
  end

  def Key::move_item_down
    win = $wins[get_win_id('feed')]
    $config['feeds'].move_down(win.active_item)
    win.move_item_down
  end

  def Key::delete
    win = $wins[get_win_id('feed')]
    $config['feeds'].delete(win.active_item)
    win.delete_item
    win.active_item = (win.active_item > 0) ? win.active_item - 1 : 0
    win.clear
    win.draw_items
  end

  def Key::sort_feeds
    win = $wins[get_win_id('feed')]

    # get old active window
    a_win = $a_win

    # sort list, repopulate window
    $config['feeds'].sort
    populate_feed_win
    
    # select first feed, redraw feed window
    win.active_item = 0
    win.draw_items
    win.select_win_item

    # reselect previous window
    set_active_win a_win
  end
  
  def Key::open_link
    win = $wins[get_win_id('desc')]
    win.select_win_item
  end
end

class FeedList
  attr_accessor :feeds
  def initialize
    @feeds = []
  end

  def size
    @feeds.size
  end
  
  def add(title, url, refresh, lock_title=false, save_items=false, site='',
          desc='', items=[])
    lock_title = false if !lock_title
    save_items = false if !save_items
    @feeds << {
      'title'   => title,
      'url'     => url,
      'refresh' => refresh,
      'site'    => site,
      'desc'    => desc,
      'updated' => 0,
      'items'   => items,
      'lock_title?' => lock_title,
      'save_items?' => save_items,
    }
  end

  def <<(feed)
    @feeds << feed
  end

  def [](*n)
    @feeds[*n]
  end
  
  def get(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds[id]
  end
  
  def delete(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds.delete_at(id)
  end

  def invalidate(id)
    raise "Invalid feed id: #{id}" unless id < @feeds.size
    @feeds[id]['updated'] = 0
  end

  def each_with_index
    @feeds.each_with_index { |feed, i| yield feed, i }
  end

  def each
    @feeds.each { |feed| yield feed }
  end

  def each_index
    @feeds.each_index { |i| yield i }
  end

  #
  # Sort feeds by title (case-insensitive).
  #
  def sort
    @feeds.sort! { |a, b|
      a['title'].downcase <=> b['title'].downcase
    }
  end

  def edit(id, opts)
    die "Invalid feed id: #{id}" unless id < @feeds.size
    refresh_interval_check opts['refresh'] if !opts['force'] &&
                                              opts.has_key?('refresh')
    ourl = $config['feeds'].get(id)['url']
    %w{title url refresh lock_title?}.each { |key|
      $config['feeds'].get(id)[key] = opts[key] if opts.has_key? key
    }
    if opts.has_key?('url') and opts['url'] != ourl
      $config['feeds'].invalidate(id)
    end
  end

  def move_up(id)
    if id > 0
      pitem = @feeds[id - 1]
      @feeds[id - 1] = @feeds[id]
      @feeds[id] = pitem
    end
  end

  def move_down(id)
    if id < @feeds.size - 1
      nitem = @feeds[id + 1]
      @feeds[id + 1] = @feeds[id]
      @feeds[id] = nitem
    end
  end

  def describe(id)
    # clear desc window
    desc_id = get_win_id 'desc'
    $wins[desc_id].clear
    
    $wins[desc_id].items = [ ] # This should only ever have one entry
    $wins[desc_id].items << {
      'real_title' => $config['feeds'][id]['title'],
      'title'      => $config['feeds'][id]['desc'],
      'date'       => $config['feeds'][id]['date'],
      'url'        => $config['feeds'][id]['url'],
      'date'       => $config['feeds'][id]['updated'].to_s,
      'read?'      => false
    }

    $wins[desc_id].draw_items
  end
    
  
  def refresh_interval_check(interval)
    if interval > 0 && interval < $config['feed_refresh_warn']
        err = <<ENDWARNING
Using a refresh interval of less than #{$config['feed_refresh_warn']} minutes
_really_ irritates some system administrators.  If you're sure you want to do
this, use the '--force' option to bypass this warning.
ENDWARNING
# '
      $stderr.puts err.reflow
      exit -1
    end
  end
  private :refresh_interval_check
end

module Feed
  # Feed::Item struct definition
  Item = Struct.new :title, :link, :desc, :date

  #
  # Return the contents of a URL
  #
  def Feed::get_url(url)
    port = 80
    use_ssl = false

    # work with a copy of the url
    url = url.dup

    # check for ssl
    if url =~ /^https:/
      raise 'HTTPS support requires OpenSSL-Ruby' unless $HAVE_SSL
      use_ssl = true
    end

    # strip 'http://' prefix from URL
    url.gsub!(%r!^\w+?://!, '') if url =~ %r!^\w+?://!

    # get host and path portions of url
    raise "Couldn't parse URL: \"#{url}\"" unless url =~ /^(.+?)\/(.*)$/
    host, path = $1, $2

    # check for port in URL
    if host =~ /:(\d+)$/
      port = $1 
      host.gsub!(/:(\d+)$/, '')
    end

    # initialize http connection
    http = Net::HTTP.start(host, port)
    http.use_ssl = use_ssl if $HAVE_SSL
    raise "Couldn't connect to host \"#{host}:#{port}\"" unless http

    # get result
    resp, ret = nil, ''
    begin
      resp, ret = http.get('/' << path)
    rescue 
      resp = $!.response

      # handle redirects
      if resp.code =~ /3\d{2}/
        ret = get_url resp['Location']
      else
        raise "HTTP Error: #$!"
      end
    end

    # close HTTP connection
    # Note: if we don't specify this, then the connection is pooled for the
    # HTTP/1.1 spec (do we prefer that kind of behavior?  maybe I should make in
    # an option)
    http.finish

    # return URL content
    ret
  end


  class Channel
    attr_accessor :title, :link, :desc, :lang, :items

    def initialize(url)
      parse_rss_url url
    end
      
    # 
    # Parse an RSS URL and return a FeedChannel object (which contains,
    # among other things, an array of feed_item structs)
    #
    def parse_rss_url(url)
      begin
        content = Feed::get_url url
      rescue
        raise "Couldn't get URL \"#{url}\": #$!."
      end

      # parse URL content
      doc = REXML::Document.new content

      # get channel info
      e = nil
      @title = e.text if e = doc.root.elements['//channel/title']
      @link = e.text if e = doc.root.elements['//channel/link']
      @desc = e.text if e = doc.root.elements['//channel/description']
      @lang = e.text if e = doc.root.elements['//channel/language']
  
      # build list of feed items
      @items = []
      doc.root.elements.each('//item') { |e| 
        # get item attributes (the ones that are set, anyway... stupid
        # RSS)
        h = {}
        [ 'title', 'link', 'description', 'date' ].each { |val|
          h[val] = (t_e = e.elements[val]) ? t_e.text : ''
        }

        # insert new item
        @items << Feed::Item.new(h['title'], h['link'],
                                 h['description'], h['date'])
      }
    end
  end
end


class Window
  attr_accessor :win, :title, :key, :colors, :active, :items, :active_item,
    :offset

  #
  # window constructor
  #
  def initialize(opts)
    coords = opts['coords'].dup
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    @active_item = 0
    @offset = 0
    @items = []

    @title = opts['title']
    
    @key = opts['key']
    @colors = opts['colors'].dup

    @win = Ncurses::newwin coords[3], coords[2], coords[1], coords[0]
    refresh
  end

  def clearrange(start, fini)
    w = dimensions[0]
    @win.color_set @colors['text'], nil
    start.upto(fini) do |line|
      Ncurses::mvwprintw @win, line, 1, ' ' * (w - 2)
    end
    @win.refresh
  end
  
  #
  # refresh window title and border (but not the contents)
  # 
  def refresh(refresh_contents = false)
    win.color_set @colors[@active ? 'a_box' : 'box'], nil
    Ncurses::box win, 0, 0
    win.color_set @colors[@active ? 'a_title' : 'title'], nil
    Ncurses::mvwprintw win, 0, 1, " #{@title} "
    win.color_set @colors['text'], nil
    Ncurses::wrefresh @win
  end

  #
  # clear window contents
  #
  def clear
    @win.color_set @colors['text'], nil
    h = dimensions[1]
    clearrange(1, h - 2)
  end

  def draw_text(text, x, y, reflow, offset)
    w,h = dimensions
    i = 0

    text = reflow_string text if reflow
    text.each_line do |line|
      i += 1
      if i >= offset && y < (h - 1)
        Ncurses::mvwprintw @win, y, x, line.gsub(/%/, '%%').slice(0, w - x - 1)
        y += 1
      end
    end
  end

  #
  # draw text in window
  #
  def draw(text, x = 1, y = 1, color = 'text', refresh_win = true,
           reflow_text = true, offset = 0)
    w, h = dimensions

    # handle color
    col = @colors[color]
    col_ary = []
    if col.is_a? Array
      col_ary = col
      col = col_ary[0]
      col_ary.each_index { |i|
        @win.attron $config['attr_palette'][col_ary[i]] if i > 0
      }
    end

    # draw text in window
    @win.color_set col, nil if color != 'text'

    draw_text(text, x, y, reflow_text, offset)

    # get default color, attributes
    col = @colors['text']
    col_ary = []
    if col.is_a? Array
      col_ary = col.dup
      col = col_ary[0]
    end

    # set back to default color
    @win.color_set col, nil
    @win.attrset Ncurses::A_NORMAL

    refresh if refresh_win
    y 
  end

  # get window width and height
  def dimensions
    ha = []; wa = []
    Ncurses::getmaxyx @win, ha, wa
    [wa[0], ha[0]]
  end

  #
  # select currently hilited window item
  #
  # XXX: This really should be split between the window classes as
  #      Appropriate -- richlowe 2003-06-23
  def select_win_item
    if @items && @items.size > 0
      if @items[@active_item].has_key? 'feed'
        select_feed @items[@active_item]['feed']
      elsif @items[@active_item].has_key? 'item'
        select_item @items[@active_item]['item']
      elsif @items[@active_item].has_key? 'url'
        # are we opening new screen windows?
        use_screen = $config['use_screen'] && in_screen?

        # drop out of curses mode
        save_screen unless use_screen

        # get browser command
        cmd = $config['browser_cmd'] % @items[@active_item]['url'].escape

        # prepend screen command if we're using it
        if use_screen
          screen_cmd = if $config['screen_cmd'] =~ /%s/
            $config['screen_cmd'] % @items[@active_item]['real_title']
          else
            $config['screen_cmd']
          end

          # build new command
          cmd = screen_cmd << ' ' << cmd
        end

        if cmd =~ $config['shell_meta_regex'] and !$config['force_url_meta']
          Ncurses::beep
          set_status "Refusing to open link containing meta-characters"
        else
          # execute command
          system cmd
        end

        # reset screen
        restore_screen unless use_screen
      end
    end
  end

  def reflow_string(str)
    w = dimensions[0]
    str.reflow(w - 4)
  end
  
  def method_missing(id)
    raise "Please implement #{self.class}##{id.id2name}"
  end
end
  
class ListWindow < Window
  #
  # redraw window items
  #
  def draw_items
    y = 0
    w, h = dimensions
    ic = 0
    @items.each { |i| 
      t = i['title'].strip_tags || ''
      text = t + ((t.length < w) ? (' ' * (w - t.length)) : '')
      if i.has_key?('item_count') && i['item_count'] == 0 &&
          i['updated'] > 0
        color = (ic == @active_item) ? 'h_empty' : 'empty'
      elsif i.has_key?('read?') && i['read?'] == false
        color = (ic == @active_item) ? 'h_unread' : 'unread'
      else
        color = (ic == @active_item) ? 'h_text' : 'text'
      end
      draw(text, 1, y += 1, color, true, false) if ic >= @offset
      ic += 1
    }
    refresh(true)
  end
  
  #
  # Adjust the window to show the selected item
  #
  def adjust_to(item)
    # scroll window (if necessary)
    w, h = dimensions
    if item < @offset || item >= @offset + (h - 3)
      @offset = @active_item
      @offset = 0 if @offset < 0
      if item + h - 3 > @items.size - 1
        @offset = @active_item - (h - 3)
        @offset = 0 if @offset < 0
      end
    end
    draw_items

    if $config['describe_hilited_feed'] == true &&
        @items[item].has_key?('feed')
      $config['feeds'].describe(item)
    end
    
    status = ' ' << @items[@active_item]['title']
    status = status.split(/\s+/).join(' ')
    set_status status

    select_win_item if $config['focus'] == 'auto'
  end
  private :adjust_to

  #
  # Activate an item
  #
  def activate(item)
    if @items.size > 0
      if item >= @items.size or item < 0
        throw "Window#activate item out of range (#{item}/#{@items.size})"
      end
      @active_item = item
      adjust_to item
    end
  end
  
  def scroll_up_page
    if $config['page_step'] < 0
      w,h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end
      
    pos = @active_item - step
    pos < 0 ? activate(0) : activate(pos)
  end

  #
  # Scroll one page down.
  #
  def scroll_down_page
    if $config['page_step'] < 0
      w,h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    pos = @active_item + step
    pos >= @items.size ? activate(@items.size - 1) : activate(pos)
  end
       
  #
  # Bound scrolling based on $config['scroll_wrapping']
  #
  def scroll_bound(point)
    if point >= @items.size
      $config['scroll_wrapping'] ? 0 : @items.size - 1
    elsif point < 0
      $config['scroll_wrapping'] ? @items.size - 1 : 0
    else
      point
    end
  end

  #
  # Scroll the window up one item
  #
  def scroll_up
      activate scroll_bound(@active_item - 1)
  end
  
  #
  # Scroll window down.
  #
  def scroll_down
      activate scroll_bound(@active_item + 1)
  end
  
  #
  # Scroll to the bottom.
  #
  def scroll_bottom
    activate @items.size - 1
  end

  #
  # Scroll to the top item
  #
  def scroll_top
    activate 0
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end
end

class TextWindow < Window
  def reflow_string(str)
    w = dimensions[0]
    str.reflow(w - 4, $config['force_text_wrap'])
  end
       
  def draw_items
    item = @items[0] # There can be only one
    y = 1
    h = dimensions[1]

    if item['real_title'] && item['real_title'] != ''
      draw(item['real_title'].strip, 1, y, 'f_title', true, false)
      y += 1
    end
    draw("Link: ", 1, y)
    # @win.color_set @colors['url'], nil
    draw(item['url'], 7, y, 'url', true, false)

    # don't draw the date if it isn't set (silly RSS)
    if item['date'] && item['date'] != '' && item['date'] != "0"
      y += 1
      draw("Date: ", 1, y)
      
      # handle date string shenanigans
      if ((i_val = item['date'].to_i) > 0)
        d_str = Time.at(i_val).strftime($config['desc_date_format'])
      else
        d_str = item['date']
      end
      
      # draw date string
      # @win.color_set @colors['date'], nil
      draw(d_str, 7, y, 'date', true, false)
    end
    if item['title']
      y += 2
      str = item['title'] || ''
      str = str.strip_tags if $config['strip_html_tags']
      str = str.unescape_html if $config['unescape_html']
      # Offset + 1, so we scroll on the *first* press
      draw(str, 1, y, 'text', true, true, @offset + 1)
      y += (reflow_string(str).lines - @offset)
    end

    # *Much* faster than a total clear each time it scrolls.
    clearrange(y, h - 2)
    
    refresh(true)
  end

  def scroll_up_page
    if $config['page_step'] < 0
      w, h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    @offset = @offset - step
    draw_items
  end

  def scroll_down_page
    if $config['page_step'] < 0
      w, h = dimensions
      step = (h - 2) + $config['page_step']
    else
      step = $config['page_step']
    end

    @offset = @offset + step
    draw_items
  end
  
  def scroll_up
    @offset -= 1 if @offset > 0
    draw_items
  end

  def scroll_down
    # This is a *terrible* way to figure out how many lines of text we'll end
    # up with.., XXX put me somewhere better.
    s = reflow_string(@items[0]['title']).lines
    @offset += 1 if @offset < s - 1
    draw_items
  end

  def scroll_bottom
    # This is a *terrible* way to figure out how many lines of text we'll end
    # up with.., XXX put me somewhere better.
    h,s = dimensions[1], 0

    %w{real_title url date}.each do |key|
      s += 1 if @items[0].has_key?(key)
    end
    s += reflow_string(@items[0]['title']).lines + 1
    @offset = s - (h - 2)
    draw_items
  end

  def scroll_top
    @offset = 0
    draw_items
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end

  def resize_width
    # XXX
  end

  def move_item_down
    if @active_item < @items.size - 1 
      nitem = @items[@active_item + 1]
      @items[@active_item + 1] = @items[@active_item]
      @items[@active_item] = nitem
      @active_item = @active_item + 1
      draw_items
    end
  end

  def move_item_up
    if @active_item > 0
      pitem = @items[@active_item - 1]
      @items[@active_item - 1] = @items[@active_item]
      @items[@active_item] = pitem
      @active_item = @active_item - 1
      draw_items
    end
  end

  def delete_item
    @items.delete_at(@active_item)
    populate_feed_win
  end

  def resize_width
    # XXX
  end
end

#
# set status bar message
#
def set_status(str)
  str ||= ''

  w, e_msg = $config['w'], $config['msg_exit']
  $status, $new_status = str, str

  # fix message length
  if str.length > (w - e_msg.length)
    str = str.slice(0, w - e_msg.length)
  else
    str += ' ' * (w - e_msg.length - str.length)
  end
  msg = str << e_msg

  Ncurses::stdscr.color_set $config['theme']['status_bar_cols'], nil
  Ncurses::mvprintw $config['h'], 0, msg
  Ncurses::refresh
end

# 
# set active window 
#
def set_active_win(a_win)
  $wins[$a_win].active = false
  $wins[$a_win].refresh

  $a_win = a_win

  $wins[$a_win].active = true
  $wins[$a_win].refresh
end

#
# get window id by key
#
def get_win_id(str)
  $wins.each_index { |i| return i if $wins[i].key == str }
  -1
end


# 
# expand path macros in $config
#
def expand_config
  $config.each { |key, val| 
    next unless val.class == String && val =~ /\${(.+?)}/
    orig_val = val.dup
    val.gsub!(/\${(.+?)}/, $config[$1])
    # puts "\"#{orig_val}\" expands to \"#{val}\""
  }
end

#
# describe the hilited feed
# 
def describe_feed(id)
  d_win = $wins[get_win_id('desc')]
  d_win.active_item = 0
  d_win.items.clear
  d_win.clear

  y = 0
  feed = $config['feeds'].get(id)

  # print title
  str = feed['title'].strip
  d_win.draw(str, 1, y += 1, 'f_title')

  # print last update
  if feed.has_key?('updated') && feed['updated'] > 0
    if feed['updated'].is_a? Fixnum
      date_str = Time.at(feed['updated']).to_s
    else
      date_str = 'never'
    end

    str = 'Updated: ' << date_str
    d_win.draw(str, 1, y += 1, 'f_update')
  end
  
  # print site url
  if $config['desc_show_site'] &&
     feed.has_key?('site') && feed['site'].length > 0
    str = feed['site']
    d_win.draw(str, 1, y += 1, 'f_site')
  end

  # print site url
  if $config['desc_show_url'] &&
     feed.has_key?('site') && feed['site'].length > 0
    str = feed['url']
    d_win.draw(str, 1, y += 1, 'f_url')
  end

  # draw poor man's divider
  if $config['desc_show_divider']
    d_win.draw('-  ' * 100, 1, y += 2, 'box', true, false)
  end

  # print error
  if feed.has_key?('error')
    d_win.draw(feed['error'], 1, y += 2, 'f_error')
  else 
    # print description
    if feed['desc'] && feed['desc'].length > 0
      str = feed['desc']
      d_win.draw(str, 1, y += 2, 'f_desc')
    end
  end
  
  # refresh window
  d_win.refresh
end

#
# set active feed by id
#
def select_feed(id)
  $a_feed = id
  $a_item = 0

  # clear item window
  item_id = get_win_id 'item'
  $wins[item_id].offset = 0
  $wins[item_id].active_item = 0
  $wins[item_id].items.clear

  $wins[get_win_id('desc')].offset = 0
  
  # unused.. remove it?
  fmt = $config['item_date_format']

  # wtf is happening here?
  raise "id.class.to_s = #{id.class.to_s}" unless id.class == Fixnum
  
  # iterate through feed items
  $config['feeds'].get(id)['items'].each_with_index { |item, i|
    # can't depend on the date being in a consistent format, or
    # being defined at all, for that matter :( :( :(
    # title = item['title'] + ' (' +
    #         Time.at(item['date'].to_i).strftime(fmt) << ')'

    # build title string
    if item['date'] && item['date'].size > 0
      d_str = item['date']
      d_str = Time.at(item['date'].to_i).strftime(fmt) if item['date'].to_i > 0
      title = "#{item['title']} (#{d_str})"
    elsif item['title'] !~ /^\s*$/ 
      title = item['title'] ? item['title'].strip : ''
    elsif item['desc'] !~ /^\s*$/ 
      # fall back on cleaned up and truncated description if we're
      # missing a title
      w, h = $wins[item_id].dimensions
      title = item['desc'].strip.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    else
      # if title is garbage and we have no description, then fall back
      # on formatted and truncated link (silly broken RSS feeds)
      title = '[' << item['url'].strip << ']'

      w, h = $wins[item_id].dimensions
      title = title.strip_tags.unescape_html.split(/\s+/).join(' ')

      if title.length > w - 5
        title = title.slice 0, w - 5
        title << '...'
      end
    end

    $wins[item_id].items << {
      'title' => title,
      'item'  => i,
      'read?' => item['read?']
    }
  }

  # redraw item window
  $wins[item_id].win.clear
  $wins[item_id].draw_items

  $config['feeds'].describe($a_feed)
  
  # activate item window
  set_active_win(item_id) if $config['focus'] == 'select'
end

#
# populate feed window
# 
def populate_feed_win 
  id = get_win_id 'feed'

  $wins[id].items.clear

  $config['feeds'].each_with_index { |feed, i|
    # count unread items
    unread_count = 0
    feed['items'].each { |item| unread_count += 1 unless item['read?'] }

    # build title
    title = feed['title'].strip << " (#{unread_count}/#{feed['items'].size})"
    $wins[id].items << {
      'title'       => title,
      'feed'        => i,
      'read?'       => unread_count == 0,
      'item_count'  => feed['items'].size,
      'updated'     => feed['updated'],
    }
  }
  $wins[id].draw_items
end

#
# set active item by id
#
def select_item(id)
  $a_item = id

  desc_id = get_win_id 'desc'
  item_id = get_win_id 'item'

  # clear description window
  $wins[desc_id].active_item = 0
  $wins[desc_id].items.clear

  # mark item as read
  $wins[item_id].items[$a_item]['read?'] = true
  $config['feeds'].get($a_feed)['items'][id]['read?'] = true

  $wins[desc_id].offset = 0
  
  # load item
  $wins[desc_id].items << {
    'title'       => $config['feeds'].get($a_feed)['items'][id]['desc'],
    'real_title'  => $config['feeds'].get($a_feed)['items'][id]['title'],
    'url'         => $config['feeds'].get($a_feed)['items'][id]['url'],
    'date'        => $config['feeds'].get($a_feed)['items'][id]['date'],
    'read?'       => $config['feeds'].get($a_feed)['items'][id]['read?'],
  }

  # redraw feed window
  populate_feed_win

  # redraw description window
  $wins[desc_id].win.clear
  $wins[desc_id].draw_items

  # activate description window
  set_active_win(desc_id) if $config['focus'] == 'select' and
                             !$config['no_desc_auto_focus']
end

#
# mark all items in feed as read
# 
def mark_items_as_read
  item_id = get_win_id 'item'
  # mark item as read
  $wins[item_id].items.each { |item| item['read?'] = true }
  $config['feeds'].get($a_feed)['items'].each { |item| item['read?'] = true }

  populate_feed_win
  $wins[item_id].draw_items
end

#
# select the next unread item
# 
def select_next_unread
  item_id = get_win_id 'item'

  ($a_item + 1).upto($wins[item_id].items.size) { |i|
    if $wins[item_id].items[i]['read?'] == false
      select_item i
      $wins[item_id].activate i
      $wins[item_id].draw_items
      return
    end
  }
end

#
# load feed cache
#
def load_feed_cache
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config['feeds'].each { |feed|
      feed['items'] = s.root?(feed['url']) ? s[feed['url']] : []
    }
  }
end

#
# save feed cache 
#
def save_feed_cache
  store = PStore::new $config['feed_cache_path']
  store.transaction { |s|
    $config['feeds'].each { |feed| s[feed['url']] = feed['items'] }
  }
end

#
# save feed list 
#
def save_feed_list
  File::open($config['feed_list_path'], 'w') { |f|
    $stdout.puts $config['msg_save_list'] if $config['raggle_mode'] == 'view'
    $stdout.flush
    $config['feeds'].each { |feed| feed['items'].clear }
    f.puts $config['feeds'].to_yaml
  }
end

#
# save theme
#
def save_theme
  File::open($config['theme_path'], 'w') { |f|
    $stdout.puts $config['msg_save_theme']
    $stdout.flush
    f.puts $config['theme'].to_yaml
  }
end

#
# handle mouse events
#
def handle_mouse(ev) 
  puts 'mouse'
end

def print_usage
  puts <<ENDUSAGE
Raggle - Console RSS feed aggregator.
Version #$VERSION, by Paul Duncan <pabs@pablotron.org> and
                      Richard Lowe <richlowe@richlowe.net>

Usage:
  #$0 [options]

Options:
  -a, --add, --add-feed         Add a new feed (requires '--title', '--url',
                                and '--refresh').
  -c, --config                  Specify an alternate config file.
  -d, --delete, --delete-feed   Delete an existing feed.
  -e, --edit, --edit-feed       Edit an existing feed.
  --force                       Force behavior Raggle won't normally allow.
                                Use this option with caution.
  -h, --help, --usage           Display this usage screen.
  -i, --invalidate              Invalidate a feed (force an update).
  -l, --list                    List existing feeds (use '--verbose' to 
                                show URLs as well).
  --lock-title                  Lock Title attribute of feed (for '--add'
                                and '--edit').
  --purge                       Purge deleted feeds from feed cache.
  -r, --refresh                 Refresh attribute of feed (for '--add' and
                                '--edit').
  --save-items                  Save old items of feed (for '--add' and
                                '--edit').
  --sort, --sort-feeds          Sort feeds by title (case-insensitive).
  -t, --title                   Title attribute of feed (for '--add' and
                                '--edit').
  --unlock-title                Unlock Title attribute of feed (for '--add'
                                and '--edit').
  --unsave-items                Don't save old items of feed (for '--add'
                                and '--edit').
  -u, --url                     URL attribute of feed (for '--add' and
                                '--edit').
  --verbose                     Turn on verbose output.
  -v, --version                 Display version information.

Examples:
  # add a new feed, refresh every 30 minutes
  #$0 -a -t 'test feed' -u http://www.example.com/feed.rss -r 30

  # list feeds and their ids
  #$0 --list

  # delete an existing feed
  #$0 --delete 12

  # set the title and refresh of an existing feed
  #$0 --edit 10 --title 'hi there!' -r 20

  # set and lock the title of feed 12
  #$0 -e 12 -t 'short title' --lock-title
  
About the Authors:
Paul Duncan <pabs@pablotron.org>
http://www.pablotron.org/

Richard Lowe <richlowe@richlowe.net>
http://www.richlowe.net/
ENDUSAGE

  exit(0)
end

#
# handle command-line options
# 
def handle_command_line(opts)
  ret = { 'mode' => 'view' }

  gopts = GetoptLong.new(
    ['--add', '-a',        '--add-feed',        GetoptLong::NO_ARGUMENT],
    ['--edit', '-e',       '--edit-feed',       GetoptLong::REQUIRED_ARGUMENT],
    ['--delete', '-d',     '--delete-feed',     GetoptLong::REQUIRED_ARGUMENT],
    ['--invalidate', '-i', '--invalidate-feed', GetoptLong::REQUIRED_ARGUMENT],
    ['--config', '-c',     '--config-file',     GetoptLong::REQUIRED_ARGUMENT],
    ['--list', '-l',                            GetoptLong::NO_ARGUMENT],
    ['--title', '-t',                           GetoptLong::REQUIRED_ARGUMENT],
    ['--url', '-u',                             GetoptLong::REQUIRED_ARGUMENT],
    ['--refresh', '-r',                         GetoptLong::REQUIRED_ARGUMENT],
    ['--version', '-v',                         GetoptLong::NO_ARGUMENT],
    ['--purge',                                 GetoptLong::NO_ARGUMENT],
    ['--sort', '--sort-feeds',                  GetoptLong::NO_ARGUMENT],
    ['--lock-title',                            GetoptLong::NO_ARGUMENT],
    ['--unlock-title',                          GetoptLong::NO_ARGUMENT],
    ['--save-items',                            GetoptLong::NO_ARGUMENT],
    ['--unsave-items',                          GetoptLong::NO_ARGUMENT],
    ['--verbose',                               GetoptLong::NO_ARGUMENT],
    ['--diag',                                  GetoptLong::NO_ARGUMENT],
    ['--help', '-h', '--usage',                 GetoptLong::NO_ARGUMENT]
  )

  begin
    gopts.each do |opt, arg|
      case opt
        when '--add'
          ret['mode'] = 'add'
        when '--edit'
          ret['mode'] = 'edit'
          ret['id'] = arg.to_i
        when'--delete'
          ret['mode'] = 'delete'
          ret['id'] = arg.to_i
        when '--invalidate'
          ret['mode'] = 'invalidate'
          ret['id'] = arg.to_i
        when '--config'
          $config['config_path'] = arg
        when '--list'
          ret['mode'] = 'list'
        when '--title'
          ret['title'] = arg
        when '--url'
          ret['url'] = arg
        when '--refresh'
          ret['refresh'] = arg.to_i
        when '--version'
          puts "Raggle v#$VERSION"
          exit 0
        when '--purge'
          ret['mode'] = 'purge'
        when '--sort', '--sort-feeds'
          ret['mode'] = 'sort'
        when '--lock-title'
          ret['lock_title?'] = true
        when '--unlock-title'
          ret['lock_title?'] = false
        when '--save-items'
          ret['save_items?'] = true
        when '--unsave-items'
          ret['save_items?'] = false
        when '--verbose'
          $config['verbose'] = true
        when '--diag'
          $config['diag'] = true
        when '-h', '--help', '--usage'
          print_usage
      end
    end
  rescue GetoptLong::InvalidOption 
    exit -1
  end

       
  # check options
  if ret['mode'] == 'add'
    ['title', 'url', 'refresh'].each { |val|
      unless ret[val]
        die "Missing '--#{val}'."
        exit -1
      end
    }
  elsif ret['mode'] == 'edit'
    unless ret['title'] || ret['url'] || ret['refresh'] ||
           ret.has_key?('lock_title?') || ret.has_key?('save_items?')
      die "Please specify a feed change to make."
    end
  end

  # return options
  ret
end

#
# print a list of feeds to stdout
#
def list_feeds
  i = -1
  if $config['verbose']
    puts 'ID, Title, URL, Refresh'
    $config['feeds'].each { |feed|
     puts "%2d, #{feed['title']}, #{feed['url']}, #{feed['refresh']}" % (i += 1)
    }
  else 
    puts 'ID, Title'
    $config['feeds'].each { |feed|
     puts "%2d, #{feed['title']}" % (i += 1)
    }
  end
end

#
# add a new feed
#
def add_feed(opts)
    $config['feeds'].add(opts['title'], opts['url'], opts['refresh'],
                         opts['lock_title?'], opts['save_items?'])
end

#
# purge extra feeds in cache
#
def purge_feed_cache
  urls = {}
  $config['feeds'].each { |feed| urls[feed['url']] = true }
  PStore::new($config['feed_cache_path']) { |cache|
    cache.roots.each { |root| 
      unless urls[root]
        $stderr.puts "Purging \"#{root}\"" if $config['verbose']
        cache[root] = nil
      end
    }
  }
end

# 
# delete a feed by id
#
def delete_feed(id)
  $config['feeds'].delete(id)
end

#
# Invalidate a feed by id
#
def invalidate_feed(id)
  $config['feeds'].invalidate(id)
end

#
# Sort feeds 
#
def sort_feeds
  $config['feeds'].sort
end

#
# edit an existing feed
#
def edit_feed(id, opts)
  $config['feeds'].edit(id, opts)
end

# 
# create a lock file for raggle
#
def create_cache_lock
  path = $config['cache_lock_path']
  
  # open cache lock for writing
  unless $config['cache_lock'] = File::open(path, 'w')
    die "Couldn't open \"#{path}\"."
  end

  # obtain cache lock
  unless $config['cache_lock'].flock(File::LOCK_EX | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't obtain cache lock: " << 
                 "Another instance of Raggle is running.\n"
    $stderr.puts "WARNING: Disabling feed caching for this instance."
    $stderr.puts "WARNING: Press enter to continue."

    # wait for user response
    $stdin.gets

    # disable feed caching and theme saving
    $config['use_cache_lock'] = false
    $config['save_feed_list'] = false
    $config['save_feed_cache'] = false
    $config['save_theme'] = false
  end
end

#
# destroy raggle lock file
#
def destroy_cache_lock
  path = $config['cache_lock_path']

  # unlock cache lock
  unless $config['cache_lock'].flock(File::LOCK_UN | File::LOCK_NB)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end

  # close cache lock
  $config['cache_lock'].flush
  $config['cache_lock'].close
  $config['cache_lock'] = nil

  # start garbage collection (flush out file descriptor)
  GC.start

  # unlink cache lock
  unless File::unlink(path)
    $stderr.puts "WARNING: Couldn't unlock \"#{path}\"."
  end
end


def resize_term
  # get screen coordinates
  h = []; w = []
  Ncurses::getmaxyx Ncurses::stdscr, h, w
  $config['w'] = w[0]
  $config['h'] = h[0] - 1

  # resize each window
  $config['theme']['window_order'].each { |key|
    win_id = get_win_id key

    # determine new coordinates
    coords = $config['theme']['win_' << key]['coords'].dup
    coords[2] = $config['w'] - coords[0] if coords[2] == -1
    coords[3] = $config['h'] - coords[1] if coords[3] == -1

    # delete old window, create new one
    $wins[win_id].win.del
    $wins[win_id].win = Ncurses::newwin coords[3], coords[2],
                                        coords[1], coords[0]

    # refresh window
    $wins[win_id].refresh
    $wins[win_id].draw_items
  }

  set_status " #{$config['msg_term_resize']}#{w[0]}x#{h[0]}"

  # refresh full screen
  Ncurses::refresh
end

#
# save scren mode, drop out of ncurses
#
def save_screen
  Ncurses::def_prog_mode
  Ncurses::endwin
end

#
# restore saved screen settings
#
def restore_screen
  Ncurses::reset_prog_mode
  Ncurses::refresh
  # Ncurses::getch
end

#
# drop to sub-shell
#
def drop_to_shell
  save_screen
  system ENV['SHELL']
  restore_screen
end

#######################################################################
# End Shenanigans, Begin Actual Code                                  #
#######################################################################

def main
  # expand the default config hash
  expand_config

  # parse command-line options
  opts = handle_command_line ARGV
  
  # if $HOME/.raggle doesn't exist, then create it
  Dir::mkdir $config['config_dir'] unless test ?d , $config['config_dir']
  
  # load user config ($HOME/.raggle/config.rb)
  puts $config['msg_load_config'] if opts['mode'] == 'view'
  load $config['config_path'], false if test ?e, $config['config_path']
  expand_config
  
  # load feed list
  puts $config['msg_load_list'] if opts['mode'] == 'view'
  if $config['load_feed_list'] && test(?e, $config['feed_list_path'])
    $config['feeds'] = YAML::load(File::open($config['feed_list_path']))
  end

  if $config['feeds'].size == 0
    $config['default_feeds'].each {|feed|
      $config['feeds'].add(feed['title'], feed['url'], feed['refresh'],
                           feed['lock_title?'], feed['save_items?'],
                           feed['site'], feed['desc'], feed['items'])
    }
  end
  
  # create cache lock
  create_cache_lock if $config['use_cache_lock']
  
  # handle command-line options
  $config['raggle_mode'] = opts['mode']
  case opts['mode']
  when 'list'
    list_feeds
    exit 0
  when 'add'
    add_feed opts
    save_feed_list
    exit 0
  when 'delete'
    delete_feed opts['id']
    save_feed_list
    exit 0
  when 'invalidate'
    invalidate_feed opts['id']
    save_feed_list
    exit 0
  when 'edit'
    edit_feed opts['id'], opts
    save_feed_list
    exit 0
  when 'sort'
    sort_feeds
    save_feed_list
    exit 0
  when 'purge'
    purge_feed_cache
    exit 0
  end
  
  # load feed cache
  load_feed_cache if $config['load_feed_cache'] &&
    test(?e, $config['feed_cache_path'])
  
  # load theme
  puts $config['msg_load_theme']
  if $config['load_theme'] && test(?e, $config['theme_path'])
    $config['theme'] = YAML::load(File::open($config['theme_path']))
  end
  
  # start feed grabbing thread
  feed_thread = Thread.new {
    File.open($config['grab_log_path'], $config['grab_log_mode']) { |log|
      log.puts "#{Time.now}: Starting grab log."
      loop {
        $config['feeds'].each { |feed|
          t = Time.now
          
          $new_status = " Checking feed \"#{feed['title']}\"..."
          log.puts "#{Time.now}: Checking feed \"#{feed['title']}\""
          next unless feed['refresh'] > 0 && 
            feed['updated'] + (feed['refresh'] * 60) < t.to_i
          
          # update statusbar and grab log
          $new_status = " Updating feed \"#{feed['title']}\"..."
          log.puts "#{t}: Updating feed \"#{feed['title']}\" from \"#{feed['url']}\""
          # set_status "Updating \"#{feed['title']}\"..."
          
          # TODO: save old items
          # old_items = feed['items']
          
          # get channel
          begin
            chan = Feed::Channel.new(feed['url'])
            feed.delete 'error'
          rescue
            # set_status "Error updating \"#{feed['title']}\"."
            log.puts "#{t}: Error: #$!"
            feed['error'] = "#$!"
            next
          end
          
          # update feed attributes
          feed['title'] = chan.title unless $config['lock_feed_title'] ||
                                            feed['lock_title?'] == true
          feed['desc'] = chan.desc
          feed['site'] = chan.link
          feed['updated'] = t.to_i
          
          # hash the urls, save the read status
          urls = {}
          feed['items'].each { |item| urls[item['url']] = item['read?'] }

          # clear the list if we're not saving feed items
          feed['items'].clear unless $config['save_feed_items'] ||
                                     feed['save_items?']
          
          # insert new items
          new_items = []
          chan.items.each { |item|
            unless (($config['save_feed_items'] || feed['save_items?']) &&
                    urls.has_key?(item.link))
              was_read = urls.has_key?(item.link) && urls[item.link]
              new_items << {
                'title' => item.title,
                'date'  => item.date,
                'url'   => item.link,
                'desc'  => item.desc,
                'read?' => was_read,
                'added' => Time.now.to_i,
              }
            end
          }
          
          # if we're saving old items, then prepend the new items
          # otherwise, replace the old list
          if $config['save_feed_items'] || feed['save_items?']
            feed['items'] = new_items + feed['items']
          else
            feed['items'] = new_items
          end
          
          # redraw feed / item windows
          $update_wins = true
        }
        
        # finish log entries
        interval = $config['feed_sleep_interval']
        $new_status = $config['msg_grab_done']
        log.puts "#{Time.now}: Done checking.  Sleeping for #{interval}s."
        log.flush
        sleep interval
      }
    }
  }

  begin
    # initialize screen & keyboard
    Ncurses::initscr
    Ncurses::raw if $config['use_raw_mode']
    Ncurses::keypad Ncurses::stdscr, 1
    Ncurses::noecho if $config['use_noecho']
    Ncurses::start_color
    # Ncurses::mousemask(Ncurses::ALL_MOUSE_EVENTS, [])
    
    # exit -1 unless Ncurses::has_colors?
    
    # initialize color pairs
    $config['color_palette'].each { |ary| Ncurses::init_pair *ary }
    
    # get screen coordinates
    h = []; w = []
    Ncurses::getmaxyx Ncurses::stdscr, h, w
    $config['w'] = w[0]
    $config['h'] = h[0] - 1
    
    # draw menu bar
    # c_msg = $config['msg_close']
    # msg = (' ' * ($config['w'] - c_msg.length)) << c_msg
    # Ncurses::wcolor_set Ncurses::stdscr, $config['menu_bar_cols'], nil
    # Ncurses::mvprintw 0, 0, msg
    # Ncurses::refresh
    
    # draw status bar
    $new_status = ''
    set_status $config['msg_welcome']
    
    # create windows
    $a_win = 0
    $wins = []
    $config['theme']['window_order'].each { |i|
      case i
        when /feed/
          cl = ListWindow
        when /item/
          cl = ListWindow
        when /desc/
          cl = TextWindow
      else
        raise "Unknown window #{i}"
      end
      $wins << cl.new($config['theme']["win_#{i}"])
      # $wins[-1].draw LONG_STRING
    }
    set_active_win(0)
    
    $a_feed, $a_item = 0, 0
    
    # populate feed window
    populate_feed_win
    
    select_feed(0)
    set_active_win(0)
    
    # trap('WINCH') { resize_term }
    
    # main input loop
    timeout = $config['input_select_timeout']
    $done = false
    until $done
      # handle keyboard input
      r = select [$stdin], nil, nil, timeout
      if r && r.size > 0
        c = Ncurses::getch
        $config['keys'][c].call($wins[$a_win], c) if $config['keys'].has_key? c
      end
      
      # refresh window contents if there's been a feed update
      if $update_wins
        $update_wins = false
        populate_feed_win
        # wins.each { |win| win.draw_items }
      end
      
      set_status $new_status if $new_status != $status
    end
  ensure
    # ignore resize signals
    # trap 'WINCH', 'IGNORE'
    
    # clean up screen on exit
    Ncurses::endwin
    
    # stop feed grabbing thread
    feed_thread.exit
    
    # save feed cache
    save_feed_cache if $config['save_feed_cache']
    
    # save feed list
    save_feed_list if $config['save_feed_list']
    
    # save theme
    save_theme if $config['save_theme']
    
    # unlock everything
    destroy_cache_lock if $config['use_cache_lock'] && $config['cache_lock']
    
    $stdout.puts $config['msg_thanks']
  end
end

##################
# default config #
##################
$config = {
  'config_dir'            => ENV['HOME'] + '/.raggle',
  'config_path'           => '${config_dir}/config.rb',
  'feed_list_path'        => '${config_dir}/feeds.yaml',
  'feed_cache_path'       => '${config_dir}/feed_cache.store',
  'theme_path'            => '${config_dir}/theme.yaml',
  'grab_log_path'         => '${config_dir}/grab.log',
  'cache_lock_path'       => '${config_dir}/lock',

  # feed list handling
  'load_feed_list'        => true,
  'save_feed_list'        => true,

  # feed cache handling
  'load_feed_cache'       => true,
  'save_feed_cache'       => true,

  # save old feed items indefinitely?
  # Note: doing this with a lot of high-traffic feeds can make
  # your feed cache grow very large, very fast.  It's probably better
  # to use the per-feed --save-items command-line option.
  'save_feed_items'       => false,

  # theme handling
  'load_theme'            => true,
  'save_theme'            => true,

  # feed list, feed cache, and theme lock handling
  'use_cache_lock'        => true,

  # ui options
  'focus'                 => 'select', # ['none', 'select', 'auto']
  'no_desc_auto_focus'    => true,
  'scroll_wrapping'       => true,

  # Number of list items per "page" (wrt page up/down)
  # (if < 0, then the height of the window, minus N items)
  'page_step'             => -3,

  # date formats
  'item_date_format'      => '%c',
  'desc_date_format'      => '%c',

  # messages
  'msg_welcome'           => " Welcome to Raggle #{$VERSION}.",
  'msg_exit'              => "| Press Q to exit ",
  'msg_close'             => '[X] ',
  'msg_grab_done'         => " Raggle #{$VERSION}",
  'msg_load_config'       => 'Raggle: Loading config...',
  'msg_load_list'         => 'Raggle: Loading feed list...',
  'msg_save_list'         => 'Raggle: Saving feed list...',
  'msg_load_cache'        => 'Raggle: Loading feed cache...',
  'msg_save_cache'        => 'Raggle: Saving feed cache...',
  'msg_load_theme'        => 'Raggle: Loading theme...',
  'msg_save_theme'        => 'Raggle: Saving theme...',
  'msg_thanks'            => 'Thanks for using Raggle!',
  'msg_term_resize'       => 'Terminal Resize: ',

  # menu bar color
  'menu_bar_cols'         => 24,

  # input select timeout (in seconds)
  'input_select_timeout'  => 0.2,

  # feed sleep interval (in seconds)
  'feed_sleep_interval'   => 60,

  # grab log mode (a == append, w == write)
  'grab_log_mode'         => 'w',

  # strip html from item contents?
  'strip_html_tags'       => true,

  # decode html escape sequences?
  'unescape_html'         => true,

  # Force wrapping of generally unwrappable lines?
  'force_text_wrap'       => false,

  # replace unicode chars with what?
  'unicode_munge_str'     => '!u!',

  # warn if feed refresh is set to less than this
  'feed_refresh_warn'     => 60,

  # open new screen window for browser?
  'use_screen'            => true,

  # screen command
  'screen_cmd'            => 'screen -t "%s"',
  
  # browser options
  'browser'               => Path::find_browser,
  'browser_cmd'           => '${browser} %s',

  # Force raggle to accept shell metacharacters in urls.
  'force_url_meta'        => false,
  # Regular expression matching shell metacharacters to not allow in URLs
  'shell_meta_regex'       => /([\`\$]|\#{)/, # the #{ is to stop ruby
                                              # expansion.
                                              # Is that necessary?

  # lock feed names (don't update feed title from feed)
  # (you can lock individual feed titles with the --lock-title command)
  'lock_feed_title'       => false,

  # feed info on hilite
  'describe_hilited_feed' => true,
  'desc_show_site'        => false,
  'desc_show_url'         => false,
  'desc_show_divider'     => false,

  # key bindings
  'keys'            => {
    Ncurses::KEY_RIGHT  => proc { |win, key| Key::next_window },
    ?\t                 => proc { |win, key| Key::next_window },

    Ncurses::KEY_LEFT   => proc { |win, key| Key::prev_window },
    ?\\                 => proc { |win, key| Key::prev_window },

    Ncurses::KEY_F12    => proc { |win, key| Key::quit },
    ?q                  => proc { |win, key| Key::quit },

    Ncurses::KEY_UP     => proc { |win, key| Key::scroll_up },
    Ncurses::KEY_DOWN   => proc { |win, key| Key::scroll_down },
    Ncurses::KEY_HOME   => proc { |win, key| Key::scroll_top },
    Ncurses::KEY_END    => proc { |win, key| Key::scroll_bottom },
    Ncurses::KEY_PPAGE  => proc { |win, key| Key::scroll_up_page },
    Ncurses::KEY_NPAGE  => proc { |win, key| Key::scroll_down_page },

    ?\n                 => proc { |win, key| Key::select_item },
    ?\                  => proc { |win, key| Key::select_item },

    ?u                  => proc { |win, key| Key::move_item_up },
    ?d                  => proc { |win, key| Key::move_item_down },

    Ncurses::KEY_DC     => proc { |win, key| Key::delete },
    ##
    # XXX: Meta can be dropped after spawned browser exits
    # So A, B, C or D should *not* be bound until this is fixed
    # -- richlowe 2003-06-22 (actually --pabs 2003-06-21)
    # ?D                  => proc { |win, key| Key::delete },


    ?r                  => proc { |win, key| resize_term },
    Ncurses::KEY_RESIZE => proc { |win, key| resize_term },

    ?s                  => proc { |win, key| Key::sort_feeds },

    ?o                  => proc { |win, key| Key::open_link },

    ?m                  => proc { |win, key| mark_items_as_read },

    ?!                  => proc { |win, key| drop_to_shell },

    ?n                  => proc { |win, key| select_next_unread },
  },

  # color palette (referenced by themes)
  'color_palette'         => [
    [  1, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLACK   ],
    [  2, Ncurses::COLOR_RED,      Ncurses::COLOR_BLACK   ],
    [  3, Ncurses::COLOR_GREEN,    Ncurses::COLOR_BLACK   ],
    [  4, Ncurses::COLOR_BLUE,     Ncurses::COLOR_BLACK   ],
    [  5, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_BLACK   ],
    [  6, Ncurses::COLOR_CYAN,     Ncurses::COLOR_BLACK   ],
    [  7, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_BLACK   ],
    [ 11, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 12, Ncurses::COLOR_BLACK,    Ncurses::COLOR_RED     ],
    [ 13, Ncurses::COLOR_BLACK,    Ncurses::COLOR_GREEN   ],
    [ 14, Ncurses::COLOR_BLACK,    Ncurses::COLOR_BLUE    ],
    [ 15, Ncurses::COLOR_BLACK,    Ncurses::COLOR_MAGENTA ],
    [ 16, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 17, Ncurses::COLOR_BLACK,    Ncurses::COLOR_YELLOW  ],
    [ 21, Ncurses::COLOR_BLACK,    Ncurses::COLOR_WHITE   ],
    [ 22, Ncurses::COLOR_WHITE,    Ncurses::COLOR_RED     ],
    [ 23, Ncurses::COLOR_WHITE,    Ncurses::COLOR_GREEN   ],
    [ 24, Ncurses::COLOR_WHITE,    Ncurses::COLOR_BLUE    ],
    [ 25, Ncurses::COLOR_WHITE,    Ncurses::COLOR_MAGENTA ],
    [ 26, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 27, Ncurses::COLOR_WHITE,    Ncurses::COLOR_YELLOW  ],
    [ 31, Ncurses::COLOR_WHITE,    Ncurses::COLOR_CYAN    ],
    [ 32, Ncurses::COLOR_RED,      Ncurses::COLOR_CYAN    ],
    [ 33, Ncurses::COLOR_GREEN,    Ncurses::COLOR_CYAN    ],
    [ 34, Ncurses::COLOR_BLUE,     Ncurses::COLOR_CYAN    ],
    [ 35, Ncurses::COLOR_MAGENTA,  Ncurses::COLOR_CYAN    ],
    [ 36, Ncurses::COLOR_BLACK,    Ncurses::COLOR_CYAN    ],
    [ 37, Ncurses::COLOR_YELLOW,   Ncurses::COLOR_CYAN    ],
  ],

  'attr_palette'          => {
    'normal'        => Ncurses::A_NORMAL,
    'normal'        => Ncurses::A_NORMAL,
    'standout'      => Ncurses::A_STANDOUT,
    'underline'     => Ncurses::A_UNDERLINE,
    'reverse'       => Ncurses::A_REVERSE,
    'blink'         => Ncurses::A_BLINK,
    'dim'           => Ncurses::A_DIM,
    'bold'          => Ncurses::A_BOLD,
    'protect'       => Ncurses::A_PROTECT,
    'invis'         => Ncurses::A_INVIS,
    'altcharset'    => Ncurses::A_ALTCHARSET,
    'chartext'      => Ncurses::A_CHARTEXT,
  },

  # default theme settings
  'theme'           => {
    # theme information
    'name'          => 'Default Theme',
    'author'        => 'Paul Duncan <pabs@pablotron.org>',
    'url'           => 'http://www.pablotron.org/software/raggle/',

    # window order (order for window changes, etc)
    'window_order'  => ['feed', 'item', 'desc'],
    
    # status bar color
    'status_bar_cols'       => 24,

    # feed window attributes
    'win_feed'      => {
      'key'         => 'feed',
      'title'       => 'Feeds',
      'coords'      => [0, 0, 25, -1],
      'type'        => 'list',
      'colors'      => { 
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        # 'a_title'   => 36,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
        'empty'     => 2,
        'h_empty'     => 32,
      },
    },

    # item window attributes
    'win_item'      => {
      'key'         => 'item',
      'title'       => 'Items',
      'coords'      => [25, 0, -1, 15],
      'type'        => 'list',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'unread'    => 6,
        'h_unread'  => 36,
      },
    },

    # desc window attributes
    'win_desc'      => {
      'key'         => 'desc',
      'title'       => 'Description',
      'coords'      => [25, 15, -1, -1],
      'type'        => 'text',
      'colors'      => {
        'title'     => 1,
        'text'      => 1,
        'h_text'    => 16,
        'box'       => 4,
        'a_title'   => 21,
        'a_box'     => 3,
        'url'       => 6,
        'date'      => 6,

        'f_title'   => [1, 'bold'],
        'f_update'  => 1,
        'f_url'     => 1,
        'f_site'    => 1,
        'f_error'   => 2,
        'f_desc'    => 1,
      },
    },
  },

  # live feeds
  'feeds'    => FeedList.new,

  # debugging / internal options (don't touch)
  'use_raw_mode'  => true,
  'use_noecho'    => true,

  'default_feeds' => [
    { 'title'     => ' Raggle', # add a space so sorting puts it at top
      'url'       => "http://www.pablotron.org/software/raggle/help-#{$VERSION}.xml",
      'site'      => 'http://www.pablotron.org/software/raggle/',
      'refresh'   => -1,
      'updated'   => 1056271511,
      'desc'      => 'Welcome to Raggle!
. .
Raggle is a console RSS aggregator, written in Ruby.  Raggle is
free software; please see the file COPYING for licensing and warranty
information.
. .
You can use the left and right arrow keys to navigate between windows.
Press Enter or Space to select the hilited item in the active window.
To launch a browser and view an item, select the item, navigate to the
Description window and press Enter.
',
      'items'     => [
        { 'title' => 'Introduction',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => 'Welcome to Raggle!
. .
Raggle is a console RSS aggregator, written in Ruby.  Raggle is
free software; please see the file COPYING for licensing and warranty
information.
', },
        { 'title' => 'License',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => 'Copyright (C) 2003
Paul Duncan, and various contributors.
. . 
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
. .
The above copyright notice and this permission notice shall be included in
all copies of the Software, its documentation and marketing & publicity 
materials, and acknowledgment shall be given in the documentation, materials
and software packages that this Software was used.
. .   
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          ', },
        { 'title' => 'Keyboard',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => '- Tab, <-, -> : Window navigation   .
- Up, Down : Item navigation        .
- Page Up, Page Down : Move up, down a page. .
- u, d : Move the current feed up or down. .
- s : Sort the feed list alphabetically. .
- Del: Delete the hilited feed. .
- o : Open the currently selected feed item. .
- Enter, Space : Select active item .
- Q, F12 : Exit Raggle              .
.
', },
        { 'title' => 'Reading Feeds',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => 'To read a given feed,
hilite it in the Feed window and press Enter or
Space.  The list of items available from that feed will be displayed in
the Item window.  Unread feed items are hilited in cyan.  To view the
full story linked from a feed item, navigate to the Description window
(using Tab or the Left and Right arrow keys) and press Enter.  
. .
If Raggle is running in a screen session, it will invoke your browser of
choice in a separate screen window (this behavior is configurable; see the
\'use_screen\' option for additional information).  There are also several
different window navigation modes available, see the \'focus\' option for
additional information.
', },
        { 'title' => 'Adding Feeds',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => 'To add a new RSS feed to Raggle,
quit out of Raggle and run the following command:
. .
raggle --add -t "title" -u "url" -r "refresh"
. .
Where "title" is the title of the feed, "url" is the URL of the feed,
and "refresh" is the refresh interval (in minutes) of the feed.
. .

Note: The title will be overwritten by the feed unless you lock the
title using the --lock-title command-line option.
', },
        { 'title' => 'Configuration Files',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => \
'$HOME/.raggle/config.rb : main configuration file .
 $HOME/.raggle/feeds.yaml : feed list .
 $HOME/.raggle/feed_cache.store : cached feed items .
 $HOME/.raggle/theme.yaml : colors, window layout .
 . .
 Note: Raggle will fall back to internal defaults if any of these
 files are deleted, or if they don\'t exist.
', },
        { 'title' => 'Reporting Bugs',
          'url'   => 'http://www.pablotron.org/software/raggle/',
          'date'  => 1056271511,
          'read?' => false,
          'desc'  => 'Please make sure you are
using the latest version of Raggle before reporting bugs.  That said,
you can submit bug reports via email to i_hate_raggle@pablotron.org.
Please make sure the phrase "RAGGLE BUG" is in the subject of the
message.
', },
      ],
    },
    { 'title'     => 'Alternet',
      'url'       => 'http://www.alternet.org/rss/rss.xml',
      'site'      => 'http://www.alternet.org/',
      'desc'      => 'Alternative News and Information.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Daily Daemon News',
      'url'       => 'http://daily.daemonnews.org/ddn.rdf.php3',
      'site'      => 'http://daemonnews.org/',
      'desc'      => 'Daily Daemon News',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'FreshMeat',
      'url'       => 'http://themes.freshmeat.net/backend/fm-newsletter.rdf',
      'site'      => 'http://www.freshmeat.net/',
      'desc'      => 'FreshMeat.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'KernelTrap',
      'url'       => 'http://kerneltrap.org/module.php?mod=node&op=feed',
      'site'      => 'http://www.kerneltrap.org/',
      'desc'      => 'KernelTrap',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Kuro5hin',
      'url'       => 'http://www.kuro5hin.org/backend.rdf',
      'site'      => 'http://www.kuro5hin.org/',
      'desc'      => 'Kuro5hin',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Linux Weekly News',
      'url'       => 'http://www.lwn.net/headlines/rss',
      'site'      => 'http://www.lwn.net/',
      'desc'      => 'Linux Weekly News',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Pablotron',
      'url'       => 'http://www.pablotron.org/?theme=rss&amp;max=15',
      'site'      => 'http://www.pablotron.org/',
      'desc'      => 'Paul Duncan\'s personal site.',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Pigdog Journal',
      'url'       => 'http://www.pigdog.org/pigdog.rdf',
      'site'      => 'http://www.pigdog.org/',
      'desc'      => 'Pigdog Journal',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'Slashdot',
      'url'       => 'http://slashdot.org/slashdot.rss',
      'site'      => 'http://www.slashdot.org/',
      'desc'      => 'Slashdot',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'This Modern World',
      'url'       => 'http://www.thismodernworld.com/index.rdf',
      'site'      => 'http://www.thismodernworld.com/',
      'desc'      => 'This Modern World',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
    { 'title'     => 'W3C',
      'url'       => 'http://www.w3.org/2000/08/w3c-synd/home.rss',
      'site'      => 'http://www.w3.org/',
      'desc'      => 'W3C',
      'refresh'   => 120,
      'updated'   => 0,
      'items'     => [ ],
    },
  ],
}

begin
  ##
  # Start
  #
  main
rescue => err
  if $config['diag']
    puts "#{err.message} (#{err.class})"
    #err.backtrace.collect! { |name| name = "[#{name}]" }
    #puts err.backtrace.reverse.join(" -> ")
    err.backtrace.each { |frame| puts frame }
  else
    die "Eeeek" # die tacks on $! for us, so we don't have to.
  end
end

